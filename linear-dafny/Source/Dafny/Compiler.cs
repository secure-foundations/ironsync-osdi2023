//-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation.  All Rights Reserved.
// Copyright by the contributors to the Dafny Project
// SPDX-License-Identifier: MIT
//
//-----------------------------------------------------------------------------
using System;
using System.CodeDom;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.IO;
using System.Diagnostics.Contracts;
using Bpl = Microsoft.Boogie;
using System.Collections.ObjectModel;
using System.Diagnostics.SymbolStore;
using System.Net.Security;
using System.Reflection.Metadata.Ecma335;
using System.Text;
using Microsoft.BaseTypes;


namespace Microsoft.Dafny {
  public abstract class Compiler {
    public Compiler(ErrorReporter reporter) {
      Reporter = reporter;
      Coverage = new CoverageInstrumenter(this);
    }

    public static string DefaultNameMain = "Main";

    public abstract string TargetLanguage { get; }
    protected virtual string ModuleSeparator { get => "."; }
    protected virtual string ClassAccessor { get => "."; }

    Stack<TargetWriter> copyInstrWriters = new Stack<TargetWriter>(); // a buffer that stores copy instructions generated by letExpr that uses out param.
    protected TopLevelDeclWithMembers thisContext;  // non-null when type members are being translated
    protected Method enclosingMethod;  // non-null when a method body is being translated
    protected Function enclosingFunction;  // non-null when a function body is being translated

    protected readonly FreshIdGenerator idGenerator = new FreshIdGenerator();

    static FreshIdGenerator compileNameIdGenerator = new FreshIdGenerator();
    public static string FreshId() {
      return compileNameIdGenerator.FreshNumericId();
    }
    public static string FreshId(string prefix) {
      return compileNameIdGenerator.FreshId(prefix);
    }

    Dictionary<Expression, int> uniqueAstNumbers = new Dictionary<Expression, int>();
    int GetUniqueAstNumber(Expression expr) {
      Contract.Requires(expr != null);
      int n;
      if (!uniqueAstNumbers.TryGetValue(expr, out n)) {
        n = uniqueAstNumbers.Count;
        uniqueAstNumbers.Add(expr, n);
      }
      return n;
    }

    public ErrorReporter Reporter;

    public CoverageInstrumenter Coverage;

    protected void Error(Bpl.IToken tok, string msg, TextWriter/*?*/ wr, params object[] args) {
      Contract.Requires(msg != null);
      Contract.Requires(args != null);

      Reporter.Error(MessageSource.Compiler, tok, msg, args);
      if (wr is TargetWriter tw) {
        tw.WriteError("/* {0} */", string.Format("Compilation error: " + msg, args));
      } else if (wr != null) {
        wr.WriteLine("/* {0} */", string.Format("Compilation error: " + msg, args));
      }
    }

    protected string IntSelect = ",int";
    protected string LambdaExecute = "";

    protected virtual void EmitHeader(Program program, TargetWriter wr) { }
    protected virtual void EmitFooter(Program program, TargetWriter wr) { }
    protected virtual void EmitBuiltInDecls(BuiltIns builtIns, TargetWriter wr) { }
    /// <summary>
    /// Emits a call to "mainMethod" as the program's entry point, if such an explicit call is
    /// required in the target language.
    /// </summary>
    public virtual void EmitCallToMain(Method mainMethod, string baseName, TargetWriter wr) { }
    /// <summary>
    /// Creates a static Main method. The caller will fill the body of this static Main with a
    /// call to the instance Main method in the enclosing class.
    /// </summary>
    protected abstract BlockTargetWriter CreateStaticMain(IClassWriter wr);
    protected abstract TargetWriter CreateModule(string moduleName, bool isDefault, bool isExtern, string/*?*/ libraryName, TargetWriter wr);
    protected abstract string GetHelperModuleName();
    protected interface IClassWriter {
      BlockTargetWriter/*?*/ CreateMethod(Method m, List<TypeArgumentInstantiation> typeArgs, bool createBody, bool forBodyInheritance, bool lookasideBody);
      BlockTargetWriter/*?*/ CreateFunction(string name, List<TypeArgumentInstantiation> typeArgs, List<Formal> formals, Type resultType, Usage resultUsage, Bpl.IToken tok, bool isStatic, bool createBody,
        MemberDecl member, bool forBodyInheritance, bool lookasideBody);
      BlockTargetWriter/*?*/ CreateGetter(string name, TopLevelDecl enclosingDecl, Type resultType, Bpl.IToken tok, bool isStatic, bool isConst, bool createBody, MemberDecl/*?*/ member, bool forBodyInheritance);  // returns null iff !createBody
      BlockTargetWriter/*?*/ CreateGetterSetter(string name, Type resultType, Bpl.IToken tok, bool isStatic, bool createBody, MemberDecl/*?*/ member, out TargetWriter setterWriter, bool forBodyInheritance);  // if createBody, then result and setterWriter are non-null, else both are null
      void DeclareField(string name, TopLevelDecl enclosingDecl, bool isStatic, bool isConst, Type type, Bpl.IToken tok, string rhs, Field/*?*/ field);
      /// <summary>
      /// InitializeField is called for inherited fields. It is in lieu of calling DeclareField and is called only if
      /// ClassesRedeclareInheritedFields==false for the compiler.
      /// </summary>
      void InitializeField(Field field, Type instantiatedFieldType, TopLevelDeclWithMembers enclosingClass);
      TextWriter/*?*/ ErrorWriter();
      void Finish();
    }
    protected virtual bool IncludeExternMembers { get => false; }
    protected virtual bool SupportsStaticsInGenericClasses => true;
    protected virtual bool TraitRepeatsInheritedDeclarations => false;
    protected IClassWriter CreateClass(string moduleName, string name, TopLevelDecl cls, TargetWriter wr) {
      return CreateClass(moduleName, name, false, null, cls.TypeArgs, cls, null, null, wr);
    }

    /// <summary>
    /// Transforms a legal file name (without extension or directory) into
    /// a legal class name in the target language
    /// </summary>
    public virtual string TransformToClassName(string baseName) {
      Contract.Requires(baseName != null);
      return baseName;
    }

    /// <summary>
    /// "tok" can be "null" if "superClasses" is.
    /// </summary>
    protected abstract IClassWriter CreateClass(string moduleName, string name, bool isExtern, string/*?*/ fullPrintName,
      List<TypeParameter> typeParameters, TopLevelDecl cls, List<Type>/*?*/ superClasses, Bpl.IToken tok, TargetWriter wr);

    /// <summary>
    /// "tok" can be "null" if "superClasses" is.
    /// </summary>
    protected abstract IClassWriter CreateTrait(string name, bool isExtern, List<TypeParameter>/*?*/ typeParameters, List<Type>/*?*/ superClasses, Bpl.IToken tok, TargetWriter wr);
    protected virtual bool SupportsProperties { get => true; }
    protected abstract BlockTargetWriter CreateIterator(IteratorDecl iter, TargetWriter wr);
    /// <summary>
    /// Returns an IClassWriter that can be used to write additional members. If "dt" is already written
    /// in the DafnyRuntime.targetlanguage file, then returns "null".
    /// </summary>
    protected abstract IClassWriter/*?*/ DeclareDatatype(DatatypeDecl dt, TargetWriter wr);
    /// <summary>
    /// Returns an IClassWriter that can be used to write additional members.
    /// </summary>
    protected abstract IClassWriter DeclareNewtype(NewtypeDecl nt, TargetWriter wr);
    protected abstract void DeclareSubsetType(SubsetTypeDecl sst, TargetWriter wr);
    protected string GetNativeTypeName(NativeType nt) {
      Contract.Requires(nt != null);
      string nativeName = null, literalSuffix = null;
      bool needsCastAfterArithmetic = false;
      GetNativeInfo(nt.Sel, out nativeName, out literalSuffix, out needsCastAfterArithmetic);
      return nativeName;
    }
    protected abstract void GetNativeInfo(NativeType.Selection sel, out string name, out string literalSuffix, out bool needsCastAfterArithmetic);

    protected List<TypeParameter> UsedTypeParameters(DatatypeDecl dt) {
      Contract.Requires(dt != null);

      var idt = dt as IndDatatypeDecl;
      if (idt == null) {
        return dt.TypeArgs;
      } else {
        Contract.Assert(idt.TypeArgs.Count == idt.TypeParametersUsedInConstructionByGroundingCtor.Length);
        var tps = new List<TypeParameter>();
        for (int i = 0; i < idt.TypeArgs.Count; i++) {
          if (idt.TypeParametersUsedInConstructionByGroundingCtor[i]) {
            tps.Add(idt.TypeArgs[i]);
          }
        }
        return tps;
      }
    }

    protected List<TypeArgumentInstantiation> UsedTypeParameters(DatatypeDecl dt, List<Type> typeArgs) {
      Contract.Requires(dt != null);
      Contract.Requires(typeArgs != null);
      Contract.Requires(dt.TypeArgs.Count == typeArgs.Count);

      var idt = dt as IndDatatypeDecl;
      if (idt == null) {
        return TypeArgumentInstantiation.ListFromClass(dt, typeArgs);
      } else {
        Contract.Assert(typeArgs.Count == idt.TypeParametersUsedInConstructionByGroundingCtor.Length);
        var r = new List<TypeArgumentInstantiation>();
        for (int i = 0; i < typeArgs.Count; i++) {
          if (idt.TypeParametersUsedInConstructionByGroundingCtor[i]) {
            r.Add(new TypeArgumentInstantiation(dt.TypeArgs[i], typeArgs[i]));
          }
        }
        return r;
      }
    }

    protected bool NeedsTypeDescriptors(List<TypeArgumentInstantiation> typeArgs) {
      Contract.Requires(typeArgs != null);
      return typeArgs.Any(ta => NeedsTypeDescriptor(ta.Formal));
    }

    protected virtual bool NeedsTypeDescriptor(TypeParameter tp) {
      Contract.Requires(tp != null);
      return tp.Characteristics.HasCompiledValue;
    }

    protected abstract string TypeDescriptor(Type type, TextWriter wr, Bpl.IToken tok);

    protected void EmitTypeDescriptorsActuals(List<TypeArgumentInstantiation> typeArgs, Bpl.IToken tok, TargetWriter wr, bool useAllTypeArgs = false) {
      var prefix = "";
      EmitTypeDescriptorsActuals(typeArgs, tok, wr, ref prefix, useAllTypeArgs);
    }

    protected void EmitTypeDescriptorsActuals(List<TypeArgumentInstantiation> typeArgs, Bpl.IToken tok, TargetWriter wr, ref string prefix, bool useAllTypeArgs = false) {
      Contract.Requires(typeArgs != null);
      Contract.Requires(tok != null);
      Contract.Requires(wr != null);
      Contract.Requires(prefix != null);

      foreach (var ta in typeArgs) {
        if (useAllTypeArgs || NeedsTypeDescriptor(ta.Formal)) {
          wr.Write("{0}{1}", prefix, TypeDescriptor(ta.Actual, wr, tok));
          prefix = ", ";
        }
      }
    }

    /// <summary>
    /// EmitTailCallStructure evolves "wr" into a structure that can be used as the jump target
    /// for tail calls (see EmitJumpToTailCallStart).
    /// The precondition of the method is:
    ///     (member is Method m0 && m0.IsTailRecursive) || (member is Function f0 && f0.IsTailRecursive)
    /// </summary>
    protected abstract BlockTargetWriter EmitTailCallStructure(MemberDecl member, BlockTargetWriter wr);
    protected abstract void EmitJumpToTailCallStart(TargetWriter wr);
    protected abstract string TypeName(Type type, TextWriter wr, Bpl.IToken tok, MemberDecl/*?*/ member = null);
    // For cases where a type looks different when it's an argument, such as (*sigh*) Java primitives
    protected virtual string TypeArgumentName(Type type, TextWriter wr, Bpl.IToken tok) {
      return TypeName(type, wr, tok);
    }
    /// <summary>
    /// This method returns the target representation of one possible value of the type.
    /// Requires: usePlaceboValue || type.HasCompilableValue
    ///
    ///   usePlaceboValue - If "true", the default value produced is one that the target language accepts as a value
    ///                  of the type, but which may not correspond to a Dafny value. This option is used when it is known
    ///                  that the Dafny program will not use the value (for example, when a field is automatically initialized
    ///                  but the Dafny program will soon assign a new value).
    /// </summary>
    protected abstract string TypeInitializationValue(Type type, TextWriter wr, Bpl.IToken tok, Usage usage, bool usePlaceboValue, bool constructTypeParameterDefaultsFromTypeDescriptors);

    protected string TypeName_UDT(string fullCompileName, UserDefinedType udt, TextWriter wr, Bpl.IToken tok) {
      Contract.Requires(fullCompileName != null);
      Contract.Requires(udt != null);
      Contract.Requires(wr != null);
      Contract.Requires(tok != null);
      Contract.Requires(udt.TypeArgs.Count == (udt.ResolvedClass == null ? 0 : udt.ResolvedClass.TypeArgs.Count));
      if (udt.ResolvedClass == null) {
        Contract.Assert(udt.ResolvedParam != null);
        return TypeName_UDT(fullCompileName, new List<TypeParameter.TPVariance>(), udt.TypeArgs, wr, tok);
      } else {
        return TypeName_UDT(fullCompileName, udt.ResolvedClass.TypeArgs.ConvertAll(tp => tp.Variance), udt.TypeArgs, wr, tok);
      }
    }
    protected abstract string TypeName_UDT(string fullCompileName, List<TypeParameter.TPVariance> variance, List<Type> typeArgs, TextWriter wr, Bpl.IToken tok);
    protected abstract string/*?*/ TypeName_Companion(Type type, TextWriter wr, Bpl.IToken tok, MemberDecl/*?*/ member);
    protected string TypeName_Companion(TopLevelDecl cls, TextWriter wr, Bpl.IToken tok) {
      Contract.Requires(cls != null);
      Contract.Requires(wr != null);
      Contract.Requires(tok != null);
      return TypeName_Companion(UserDefinedType.FromTopLevelDecl(tok, cls), wr, tok, null);
    }
    /// Return the "native form" of a type, to which EmitCoercionToNativeForm coerces it.
    protected virtual Type NativeForm(Type type) {
      return type;
    }

    protected abstract bool DeclareFormal(string prefix, string name, Type type, Bpl.IToken tok, Usage usage, bool isInParam, bool isInoutParam, TextWriter wr);
    /// <summary>
    /// If "leaveRoomForRhs" is false and "rhs" is null, then generates:
    ///     type name;
    /// If "leaveRoomForRhs" is false and "rhs" is non-null, then generates:
    ///     type name = rhs;
    /// If "leaveRoomForRhs" is true, in which case "rhs" must be null, then generates:
    ///     type name
    /// which is intended to be followed up by a call to EmitAssignmentRhs.
    /// In the above, if "type" is null, then it is replaced by "var" or "let".
    /// "tok" is allowed to be null if "type" is.
    /// </summary>
    protected abstract void DeclareLocalVar(string name, Type/*?*/ type, Bpl.IToken /*?*/ tok, Usage usage, bool leaveRoomForRhs, string/*?*/ rhs, TargetWriter wr, bool as_pointer_for_shared);

    protected virtual void DeclareLocalVar(string name, Type /*?*/ type, Bpl.IToken /*?*/ tok, Usage usage, bool leaveRoomForRhs, string /*?*/ rhs, TargetWriter wr, Type t, bool as_pointer_for_shared) {
      DeclareLocalVar(name, type, tok, usage, leaveRoomForRhs, rhs, wr, as_pointer_for_shared);
    }
    /// <summary>
    /// Generates:
    ///     type name = rhs;
    /// In the above, if "type" is null, then it is replaced by "var" or "let".
    /// "tok" is allowed to be null if "type" is.
    /// </summary>
    protected virtual void DeclareLocalVar(string name, Type/*?*/ type, Bpl.IToken/*?*/ tok, Usage usage, Expression rhs, bool inLetExprBody, TargetWriter wr, bool as_pointer_for_shared) {
      var w = DeclareLocalVar(name, type, tok, usage, wr, as_pointer_for_shared);
      TrExpr(rhs, w, inLetExprBody);
    }

    protected virtual void DeclareLocalVar(string name, Type /*?*/ type, Bpl.IToken /*?*/ tok, Usage usage, Expression rhs,
      bool inLetExprBody, TargetWriter wr, Type t, bool as_pointer_for_shared){
      var w = DeclareLocalVar(name, type, tok, usage, wr, as_pointer_for_shared);
      TrExpr(rhs, w, inLetExprBody);
    }
    /// <summary>
    /// Generates
    ///     type name = <<writer returned>>;
    /// In the above, if "type" is null, then it is replaced by "var" or "let".
    /// "tok" is allowed to be null if "type" is.
    /// </summary>
    protected abstract TargetWriter DeclareLocalVar(string name, Type/*?*/ type, Bpl.IToken/*?*/ tok, Usage usage, TargetWriter wr, bool as_pointer_for_shared);
    protected virtual void DeclareOutCollector(string collectorVarName, TargetWriter wr) { }  // called only for return-style calls
    protected virtual void DeclareSpecificOutCollector(string collectorVarName, TargetWriter wr, List<Type> formalTypes, List<Type> lhsTypes) { DeclareOutCollector(collectorVarName, wr); } // for languages that don't allow "let" or "var" expressions
    protected virtual bool UseReturnStyleOuts(Method m, int nonGhostOutCount) => false;
    protected virtual BlockTargetWriter EmitMethodReturns(Method m, BlockTargetWriter wr) { return wr; } // for languages that need explicit return statements not provided by Dafny
    protected virtual bool SupportsMultipleReturns { get => false; }
    protected virtual bool SupportsAmbiguousTypeDecl { get => true; }
    protected virtual bool ClassesRedeclareInheritedFields => true;
    protected virtual void AddTupleToSet(int i) { }
    public int TargetTupleSize = 0;
    /// The punctuation that comes at the end of a statement.  Note that
    /// statements are followed by newlines regardless.
    protected virtual string StmtTerminator { get => ";"; }
    public void EndStmt(TargetWriter wr) { wr.WriteLine(StmtTerminator); }
    protected abstract void DeclareLocalOutVar(string name, Type type, Bpl.IToken tok, Usage usage, string rhs, bool useReturnStyleOuts, TargetWriter wr);
    protected virtual void EmitActualOutArg(string actualOutParamName, TextWriter wr) { }  // actualOutParamName is always the name of a local variable; called only for non-return-style outs
    protected virtual void EmitOutParameterSplits(string outCollector, List<string> actualOutParamNames, TargetWriter wr) { }  // called only for return-style calls
    protected virtual void EmitCastOutParameterSplits(string outCollector, List<string> actualOutParamNames, TargetWriter wr, List<Type> formalOutParamTypes, List<Type> lhsTypes, Bpl.IToken tok) {
      EmitOutParameterSplits(outCollector, actualOutParamNames, wr); }

    protected abstract void EmitActualTypeArgs(List<Type> typeArgs, Bpl.IToken tok, TextWriter wr);

    protected virtual void EmitNameAndActualTypeArgs(string protectedName, List<Type> typeArgs, Bpl.IToken tok, TextWriter wr) {
      wr.Write(protectedName);
      EmitActualTypeArgs(typeArgs, tok, wr);
    }
    protected abstract string GenerateLhsDecl(string target, Type/*?*/ type, TextWriter wr, Bpl.IToken tok);

    protected virtual TargetWriter DeclareLocalVar(string name, Type /*?*/ type, Bpl.IToken /*?*/ tok, Usage usage, TargetWriter wr, Type t, bool as_pointer_for_shared){
      return DeclareLocalVar(name, type, tok, usage, wr, as_pointer_for_shared);
    }

    protected virtual TargetWriter EmitAssignment(ILvalue wLhs, Type/*?*/ lhsType, Type/*?*/ rhsType, TargetWriter wr) {
      var w = wLhs.EmitWrite(wr);
      w = EmitCoercionIfNecessary(rhsType, lhsType, Bpl.Token.NoToken, w);
      w = EmitDowncastIfNecessary(rhsType, lhsType, Bpl.Token.NoToken, w);
      return w;
    }

    protected virtual void EmitAssignment(out TargetWriter wLhs, Type/*?*/ lhsType, out TargetWriter wRhs, Type/*?*/ rhsType, TargetWriter wr) {
      wLhs = wr.Fork();
      wr.Write(" = ");
      var w = wr;
      w = EmitCoercionIfNecessary(rhsType, lhsType, Bpl.Token.NoToken, w);
      w = EmitDowncastIfNecessary(rhsType, lhsType, Bpl.Token.NoToken, w);
      wRhs = w.Fork();
      EndStmt(wr);
    }
    protected void EmitAssignment(string lhs, Type/*?*/ lhsType, string rhs, Type/*?*/ rhsType, TargetWriter wr) {
      EmitAssignment(out var wLhs, lhsType, out var wRhs, rhsType, wr);
      wLhs.Write(lhs);
      wRhs.Write(rhs);
    }
    protected void EmitAssignmentRhs(string rhs, TargetWriter wr) {
      var w = EmitAssignmentRhs(wr);
      w.Write(rhs);
    }
    protected void EmitAssignmentRhs(Expression rhs, bool inLetExprBody, TargetWriter wr) {
      var w = EmitAssignmentRhs(wr);
      TrExpr(rhs, w, inLetExprBody);
    }

    protected virtual TargetWriter EmitAssignmentRhs(TargetWriter wr) {
      wr.Write(" = ");
      var w = wr.Fork();
      EndStmt(wr);
      return w;
    }

    protected virtual string EmitAssignmentLhs(Expression e, TargetWriter wr) {
      var target = idGenerator.FreshId("_lhs");
      wr.Write(GenerateLhsDecl(target, e.Type, wr, null));
      wr.Write(" = ");
      TrExpr(e,wr,false);
      EndStmt(wr);
      return target;
    }

    protected virtual void EmitMultiAssignment(List<Expression> lhsExprs, List<ILvalue> lhss, List<Type> lhsTypes, out List<TargetWriter> wRhss,
      List<Type> rhsTypes, TargetWriter wr) {
      Contract.Assert(lhss.Count == lhsTypes.Count);
      Contract.Assert(lhsTypes.Count == rhsTypes.Count);

      wRhss = new List<TargetWriter>();
      var rhsVars = new List<string>();
      foreach (var rhsType in rhsTypes) {
        string target = idGenerator.FreshId("_rhs");
        rhsVars.Add(target);
        wr.Write(GenerateLhsDecl(target, rhsType, wr, Bpl.Token.NoToken));
        wRhss.Add(EmitAssignmentRhs(wr));
      }

      List<ILvalue> lhssn;
      if (lhss.Count > 1) {
        lhssn = new List<ILvalue>();
        for (int i = 0; i < lhss.Count; ++i) {
          Expression lexpr = lhsExprs[i].Resolved;
          ILvalue lhs = lhss[i];
          if (lexpr is IdentifierExpr) {
            lhssn.Add(lhs);
          } else if (lexpr is MemberSelectExpr) {
            var resolved = (MemberSelectExpr)lexpr;
            string target = EmitAssignmentLhs(resolved.Obj, wr);
            var typeArgs = TypeArgumentInstantiation.ListFromMember(resolved.Member, null, resolved.TypeApplication_JustMember);
            ILvalue newLhs =  EmitMemberSelect(w => w.Write(target), resolved.Obj.Type, resolved.Member, typeArgs, resolved.TypeArgumentSubstitutionsWithParents(), resolved.Type);
            lhssn.Add(newLhs);
          } else if (lexpr is SeqSelectExpr) {
            var seqExpr = (SeqSelectExpr)lexpr;
            string targetArray = EmitAssignmentLhs(seqExpr.Seq, wr);
            string targetIndex = EmitAssignmentLhs(seqExpr.E0, wr);
            if (seqExpr.Seq.Type.IsArrayType || seqExpr.Seq.Type.AsSeqType != null) {
              targetIndex = ArrayIndexToNativeInt(targetIndex, seqExpr.E0.Type);
            }
            ILvalue newLhs = EmitArraySelectAsLvalue(targetArray,
                            new List<string>() { targetIndex }, lhsTypes[i]);
            lhssn.Add(newLhs);
          } else if (lexpr is MultiSelectExpr) {
            var seqExpr = (MultiSelectExpr)lexpr;
            Expression array = seqExpr.Array;
            List<Expression> indices = seqExpr.Indices;
            string targetArray = EmitAssignmentLhs(array, wr);
            var targetIndices = new List<string>();
            foreach (var index in indices) {
              string targetIndex = EmitAssignmentLhs(index, wr);
              targetIndices.Add(targetIndex);
            }
            ILvalue newLhs = EmitArraySelectAsLvalue(targetArray, targetIndices, lhsTypes[i]);
            lhssn.Add(newLhs);
          } else  {
            Contract.Assert(false); // Unknown kind of expression
            lhssn.Add(lhs);
          }
        }
      } else {
        lhssn = lhss;
      }

      Contract.Assert(rhsVars.Count == lhsTypes.Count);
      for (int i = 0; i < rhsVars.Count; i++) {
        TargetWriter wRhsVar = EmitAssignment(lhssn[i], lhsTypes[i], rhsTypes[i], wr);
        wRhsVar.Write(rhsVars[i]);
      }
    }

    protected virtual void EmitSetterParameter(TargetWriter wr) {
      wr.Write("value");
    }
    protected abstract void EmitPrintStmt(TargetWriter wr, Expression arg);
    protected abstract void EmitReturn(List<Formal> outParams, TargetWriter wr);
    protected virtual void EmitReturnExpr(Expression expr, Type resultType, bool inLetExprBody, TargetWriter wr, bool pointer) {  // emits "return <expr>;" for function bodies
      var w = EmitReturnExpr(wr, pointer);
      TrExpr(expr, w, inLetExprBody);
    }
    protected virtual void EmitReturnExpr(string returnExpr, TargetWriter wr, bool pointer) {  // emits "return <returnExpr>;" for function bodies
      var w = EmitReturnExpr(wr, pointer);
      w.Write(returnExpr);
    }
    protected virtual TargetWriter EmitReturnExpr(TargetWriter wr, bool pointer) {
      // emits "return <returnExpr>;" for function bodies
      wr.Write("return ");
      if (pointer) { wr.Write("&( "); }
      var w = wr.Fork();
      if (pointer) { wr.Write(" )"); }
      EndStmt(wr);
      return w;
    }
    
    /// <summary>
    /// Labels the code written to the TargetWriter returned, in such that way that any
    /// emitted break to the label inside that code will abruptly end the execution of the code.
    /// </summary>
    protected abstract TargetWriter CreateLabeledCode(string label, TargetWriter wr);
    protected abstract void EmitBreak(string/*?*/ label, TargetWriter wr);
    protected abstract void EmitYield(TargetWriter wr);
    protected abstract void EmitAbsurd(string/*?*/ message, TargetWriter wr);
    protected virtual void EmitAbsurd(string message, TargetWriter wr, bool needIterLimit) {
      EmitAbsurd(message, wr);
    }

    protected abstract void EmitHalt(Bpl.IToken tok, Expression /*?*/ messageExpr, TargetWriter wr);

    protected TargetWriter EmitIf(string guard, bool hasElse, TargetWriter wr) {
      TargetWriter guardWriter;
      var thn = EmitIf(out guardWriter, hasElse, wr);
      guardWriter.Write(guard);
      return thn;
    }
    protected virtual TargetWriter EmitIf(out TargetWriter guardWriter, bool hasElse, TargetWriter wr) {
      wr.Write("if (");
      guardWriter = wr.Fork();
      if (hasElse) {
        var thn = wr.NewBlock(")", " else", BlockTargetWriter.BraceStyle.Space, BlockTargetWriter.BraceStyle.Space);
        return thn;
      } else {
        var thn = wr.NewBlock(")");
        return thn;
      }
    }
    protected virtual TargetWriter EmitWhile(Bpl.IToken tok, List<Statement> body, TargetWriter wr) {  // returns the guard writer
      TargetWriter guardWriter;
      var wBody = CreateWhileLoop(out guardWriter, wr);
      Coverage.Instrument(tok, "while body", wBody);
      TrStmtList(body, wBody);
      return guardWriter;
    }

    protected virtual BlockTargetWriter CreateWhileLoop(out TargetWriter guardWriter, TargetWriter wr) {
      wr.Write("while (");
      guardWriter = wr.Fork();
      var wBody = wr.NewBlock(")");
      return wBody;
    }
    protected abstract BlockTargetWriter CreateForLoop(string indexVar, string bound, TargetWriter wr);
    protected abstract BlockTargetWriter CreateDoublingForLoop(string indexVar, int start, TargetWriter wr);
    protected abstract void EmitIncrementVar(string varName, TargetWriter wr);  // increments a BigInteger by 1
    protected abstract void EmitDecrementVar(string varName, TargetWriter wr);  // decrements a BigInteger by 1

    protected abstract string GetQuantifierName(string bvType);

    /// <summary>
    /// Emit a loop like this:
    ///     foreach (tmpVarName:collectionElementType in [[collectionWriter]]) {
    ///       if (tmpVarName is member of type boundVarType) {
    ///         var boundVarName:boundVarType := tmpVarName as boundVarType;
    ///         [[bodyWriter]]
    ///       }
    ///     }
    /// where
    ///   * "[[collectionWriter]]" is the writer returned as "collectionWriter"
    ///   * "[[bodyWriter]]" is the block writer returned
    /// Option:
    ///   * "introduceBoundVar" can be "false", which says to do the assignment to "boundVarName" as
    ///     shown above, but without also declaring the variable "boundVarName".
    /// </summary>
    protected abstract BlockTargetWriter CreateForeachLoop(string tmpVarName, Type collectionElementType, string boundVarName, Type boundVarType, bool introduceBoundVar,
      Bpl.IToken tok, out TargetWriter collectionWriter, TargetWriter wr);

    /// <summary>
    /// Emit a simple foreach loop over the elements (which are known as "ingredients") of a collection assembled for
    /// the purpose of compiling a "forall" statement.
    ///
    ///     foreach (boundVarName:boundVarType in [[coll]]) {
    ///       [[body]]
    ///     }
    ///
    /// where "boundVarType" is an L-tuple whose components are "tupleTypeArgs" (see EmitIngredients). If "boundVarType" can
    /// be inferred from the ingredients emitted by EmitIngredients, then "L" and "tupleTypeArgs" can be ignored and
    /// "boundVarType" be replaced by some target-language way of saying "please infer the type" (like "var" in C#).
    /// </summary>
    protected abstract BlockTargetWriter CreateForeachIngredientLoop(string boundVarName, int L, string tupleTypeArgs, out TargetWriter collectionWriter, TargetWriter wr);

    /// <summary>
    /// If "initCall" is non-null, then "initCall.Method is Constructor".
    /// </summary>
    protected abstract void EmitNew(Type type, Bpl.IToken tok, CallStmt/*?*/ initCall, TargetWriter wr);
    protected abstract void EmitNewArray(Type elmtType, Bpl.IToken tok, List<Expression> dimensions, bool mustInitialize, TargetWriter wr);

    protected abstract void EmitLiteralExpr(TextWriter wr, LiteralExpr e);
    protected abstract void EmitStringLiteral(string str, bool isVerbatim, TextWriter wr);
    protected abstract TargetWriter EmitBitvectorTruncation(BitvectorType bvType, bool surroundByUnchecked, TargetWriter wr);
    protected delegate void FCE_Arg_Translator(Expression e, TargetWriter wr, bool inLetExpr=false);

    protected abstract void EmitRotate(Expression e0, Expression e1, bool isRotateLeft, TargetWriter wr, bool inLetExprBody, FCE_Arg_Translator tr);
    /// <summary>
    /// Return true if x < 0 should be rendered as sign(x) < 0 when x has the
    /// given type.  Typically, this is only a win at non-native types, since
    /// BigIntegers benefit from not having to access the number zero.
    /// </summary>
    protected virtual bool CompareZeroUsingSign(Type type) {
      return false;
    }
    protected virtual TargetWriter EmitSign(Type type, TargetWriter wr) {
      // Currently, this should only be called when CompareZeroUsingSign is true
      Contract.Assert(false);
      throw new cce.UnreachableException();
    }
    protected abstract void EmitEmptyTupleList(string tupleTypeArgs, TargetWriter wr);
    protected abstract TargetWriter EmitAddTupleToList(string ingredients, string tupleTypeArgs, TargetWriter wr);
    protected abstract void EmitTupleSelect(string prefix, int i, TargetWriter wr);

    protected virtual bool NeedsCastFromTypeParameter => false;

    protected virtual bool IsCoercionNecessary(Type /*?*/ from, Type /*?*/ to) {
      return NeedsCastFromTypeParameter;
    }

    /// <summary>
    /// If "from" and "to" are both given, and if a "from" needs an explicit coercion in order to become a "to", emit that coercion.
    /// Needed in languages where either
    ///   (a) we need to represent upcasts as explicit operations (like Go, or array types in Java), or
    ///   (b) there's static typing but no parametric polymorphism (like Go) so that lots of things need to be boxed and unboxed.
    /// </summary>
    protected virtual TargetWriter EmitCoercionIfNecessary(Type/*?*/ from, Type/*?*/ to, Bpl.IToken tok, TargetWriter wr) {
      return wr;
    }

    protected TargetWriter EmitDowncastIfNecessary(Type /*?*/ from, Type /*?*/ to, Bpl.IToken tok, TargetWriter wr) {
      Contract.Requires(tok != null);
      Contract.Requires(wr != null);
      if (from != null && to != null) {
        if (!IsTargetSupertype(to, from)) {
          // The following assert is a sanity check. Note, in a language with NeedsCastFromTypeParameter, "to" and "from" may
          // contain uninstantiated formal type parameters.
          Contract.Assert(NeedsCastFromTypeParameter || IsTargetSupertype(from, to));
          wr = EmitDowncast(from, to, tok, wr);
        }
      }
      return wr;
    }

    /// <summary>
    /// Determine if "to" is a supertype of "from" in the target language, if "!typeEqualityOnly".
    /// Determine if "to" is equal to "from" in the target language, if "typeEqualityOnly".
    /// This to similar to Type.IsSupertype and Type.Equals, respectively, but ignores subset types (that
    /// is, always uses the base type of any subset type).
    /// </summary>
    public static bool IsTargetSupertype(Type to, Type from, bool typeEqualityOnly = false) {
      Contract.Requires(from != null);
      Contract.Requires(to != null);
      to = to.NormalizeExpand();
      from = from.NormalizeExpand();
      if (Type.SameHead(to, from)) {
        Contract.Assert(to.TypeArgs.Count == from.TypeArgs.Count);
        var formalTypeParameters = (to as UserDefinedType)?.ResolvedClass?.TypeArgs;
        Contract.Assert(formalTypeParameters == null || formalTypeParameters.Count == to.TypeArgs.Count);
        Contract.Assert(formalTypeParameters != null || to.TypeArgs.Count == 0 || to is CollectionType);
        for (var i = 0; i < to.TypeArgs.Count; i++) {
          bool okay;
          if (typeEqualityOnly) {
            okay = IsTargetSupertype(to.TypeArgs[i], from.TypeArgs[i], true);
          } else if (formalTypeParameters == null || formalTypeParameters[i].Variance == TypeParameter.TPVariance.Co) {
            okay = IsTargetSupertype(to.TypeArgs[i], from.TypeArgs[i]);
          } else if (formalTypeParameters[i].Variance == TypeParameter.TPVariance.Co) {
            okay = IsTargetSupertype(from.TypeArgs[i], to.TypeArgs[i]);
          } else {
            okay = IsTargetSupertype(to.TypeArgs[i], from.TypeArgs[i], true);
          }
          if (!okay) {
            return false;
          }
        }
        return true;
      } else if (typeEqualityOnly) {
        return false;
      } else if (to.IsObjectQ) {
        return true;
      } else {
        return from.ParentTypes().Any(fromParentType => IsTargetSupertype(to, fromParentType));
      }
    }

    protected virtual TargetWriter EmitDowncast(Type from, Type to, Bpl.IToken tok, TargetWriter wr) {
      Contract.Requires(from != null);
      Contract.Requires(to != null);
      Contract.Requires(tok != null);
      Contract.Requires(wr != null);
      Contract.Requires(!IsTargetSupertype(to, from));
      return wr;
    }

    protected virtual TargetWriter EmitCoercionToNativeForm(Type/*?*/ from, Bpl.IToken tok, TargetWriter wr) {
      return wr;
    }
    protected virtual TargetWriter EmitCoercionFromNativeForm(Type/*?*/ to, Bpl.IToken tok, TargetWriter wr) {
      return wr;
    }
    protected virtual TargetWriter EmitCoercionToNativeInt(TargetWriter wr) {
      return wr;
    }
    /// <summary>
    /// Emit a coercion of a value to any tuple, returning the writer for the value to coerce.  Needed in translating ForallStmt because some of the tuple components are native ints for which we have no Type object, but Go needs to coerce the value that comes out of the iterator.  Safe to leave this alone in subclasses that don't have the same problem.
    /// </summary>
    protected virtual TargetWriter EmitCoercionToArbitraryTuple(TargetWriter wr) {
      return wr;
    }
    protected virtual string IdName(TopLevelDecl d) {
      Contract.Requires(d != null);
      return IdProtect(d.CompileName);
    }
    protected virtual string IdName(MemberDecl member) {
      Contract.Requires(member != null);
      return IdProtect(member.CompileName);
    }
    protected virtual string IdName(TypeParameter tp) {
      Contract.Requires(tp != null);
      return IdProtect(tp.CompileName);
    }
    protected virtual string IdName(IVariable v) {
      Contract.Requires(v != null);
      return IdProtect(v.CompileName);
    }
    protected virtual string IdMemberName(MemberSelectExpr mse) {
      Contract.Requires(mse != null);
      return IdProtect(mse.MemberName);
    }
    protected virtual string IdProtect(string name) {
      Contract.Requires(name != null);
      return name;
    }
    protected abstract string FullTypeName(UserDefinedType udt, MemberDecl/*?*/ member = null);
    protected abstract void EmitThis(TargetWriter wr);
    protected virtual void EmitNull(Type type, TargetWriter wr) {
      wr.Write("null");
    }
    protected virtual void EmitITE(Expression guard, Expression thn, Expression els, Type resultType, bool inLetExprBody, TargetWriter wr) {
      Contract.Requires(guard != null);
      Contract.Requires(thn != null);
      Contract.Requires(thn.Type != null);
      Contract.Requires(els != null);
      Contract.Requires(resultType != null);
      Contract.Requires(wr != null);

      resultType = resultType.NormalizeExpand();
      wr.Write("((");
      TrExpr(guard, wr, inLetExprBody);
      wr.Write(") ? (");
      TrExpr(thn, resultType.Equals(thn.Type.NormalizeExpand()) ? wr : EmitCast(resultType, wr), inLetExprBody);
      wr.Write(") : (");
      TrExpr(els, resultType.Equals(els.Type.NormalizeExpand()) ? wr : EmitCast(resultType, wr), inLetExprBody);
      wr.Write("))");
    }

    protected virtual TargetWriter EmitCast(Type toType, TargetWriter wr) {
      wr.Write("({0})(", TypeName(toType, wr, Bpl.Token.NoToken));
      var exprWr = wr.Fork();
      wr.Write(")");
      return exprWr;
    }
    protected abstract void EmitDatatypeValue(DatatypeValue dtv, string arguments, TargetWriter wr);
    protected abstract void GetSpecialFieldInfo(SpecialField.ID id, object idParam, Type receiverType, out string compiledName, out string preString, out string postString);

    /// <summary>
    /// A "TypeArgumentInstantiation" is essentially a pair consisting of a formal type parameter and an actual type for that parameter.
    /// </summary>
    public class TypeArgumentInstantiation
    {
      public readonly TypeParameter Formal;
      public readonly Type Actual;

      public TypeArgumentInstantiation(TypeParameter formal, Type actual) {
        Contract.Requires(formal != null);
        Contract.Requires(actual != null);
        Formal = formal;
        Actual = actual;
      }

      /// <summary>
      /// Uses "formal" for both formal and actual.
      /// </summary>
      public TypeArgumentInstantiation(TypeParameter formal) {
        Contract.Requires(formal != null);
        Formal = formal;
        Actual = new UserDefinedType(formal);
      }

      public static List<TypeArgumentInstantiation> ListFromMember(MemberDecl member, List<Type> /*?*/ classActuals, List<Type> /*?*/ memberActuals) {
        Contract.Requires(classActuals == null || classActuals.Count == (member.EnclosingClass == null ? 0 : member.EnclosingClass.TypeArgs.Count));
        Contract.Requires(memberActuals == null || memberActuals.Count == (member is ICallable ic ? ic.TypeArgs.Count : 0));

        var r = new List<TypeArgumentInstantiation>();
        void add(List<TypeParameter> formals, List<Type> actuals) {
          Contract.Assert(formals.Count == actuals.Count);
          for (var i = 0; i < formals.Count; i++) {
            r.Add(new TypeArgumentInstantiation(formals[i], actuals[i]));
          }
        };

        if (classActuals != null && classActuals.Count != 0) {
          Contract.Assert(member.EnclosingClass.TypeArgs.TrueForAll(ta => ta.Parent is TopLevelDecl));
          add(member.EnclosingClass.TypeArgs, classActuals);
        }
        if (memberActuals != null && member is ICallable icallable) {
          Contract.Assert(icallable.TypeArgs.TrueForAll(ta => !(ta.Parent is TopLevelDecl)));
          add(icallable.TypeArgs, memberActuals);
        }
        return r;
      }

      public static List<TypeArgumentInstantiation> ListFromClass(TopLevelDecl cl, List<Type> actuals) {
        Contract.Requires(cl != null);
        Contract.Requires(actuals != null);
        Contract.Requires(cl.TypeArgs.Count == actuals.Count);

        var r = new List<TypeArgumentInstantiation>();
        for (var i = 0; i < cl.TypeArgs.Count; i++) {
          r.Add(new TypeArgumentInstantiation(cl.TypeArgs[i], actuals[i]));
        }
        return r;
      }

      public static List<TypeArgumentInstantiation> ListFromFormals(List<TypeParameter> formals) {
        Contract.Requires(formals != null);
        return formals.ConvertAll(tp => new TypeArgumentInstantiation(tp, new UserDefinedType(tp)));
      }

      public static List<TypeParameter> ToFormals(List<TypeArgumentInstantiation> typeArgs) {
        Contract.Requires(typeArgs != null);
        return typeArgs.ConvertAll(ta => ta.Formal);
      }

      public static List<Type> ToActuals(List<TypeArgumentInstantiation> typeArgs) {
        Contract.Requires(typeArgs != null);
        return typeArgs.ConvertAll(ta => ta.Actual);
      }
    }

    /// <summary>
    /// Answers two questions whose answers are used to filter type parameters.
    /// For a member c, F, or M:
    ///     (co-)datatype/class/trait <<cl>> {
    ///       <<isStatic>> const c ...
    ///       <<isStatic>> function method F ...
    ///       <<isStatic>> method M ...
    ///     }
    /// does a type parameter of "cl"
    ///  - get compiled as a type parameter of the member (needsTypeParameter)
    ///  - get compiled as a type descriptor of the member (needsTypeDescriptor)
    /// For a member of a trait with a rhs/body, if "lookasideBody" is "true", the questions are to
    /// be answered for the member emitted into the companion class, not the signature that goes into
    /// the target type.
    /// </summary>
    protected virtual void TypeArgDescriptorUse(bool isStatic, bool lookasideBody, TopLevelDeclWithMembers cl, out bool needsTypeParameter, out bool needsTypeDescriptor) {
      Contract.Requires(cl is DatatypeDecl || cl is ClassDecl);
      throw new NotImplementedException();
    }

    protected List<TypeArgumentInstantiation> ForTypeParameters(List<TypeArgumentInstantiation> typeArgs, MemberDecl member, bool lookasideBody) {
      Contract.Requires(member is ConstantField || member is Function || member is Method);
      Contract.Requires(typeArgs != null);
      var memberHasBody =
        (member is ConstantField cf && cf.Rhs != null) ||
        (member is Function f && f.Body != null) ||
        (member is Method m && m.Body != null);
      var r = new List<TypeArgumentInstantiation>();
      foreach (var ta in typeArgs) {
        var tp = ta.Formal;
        if (tp.Parent is TopLevelDeclWithMembers) {
          TypeArgDescriptorUse(member.IsStatic, lookasideBody, (TopLevelDeclWithMembers)member.EnclosingClass, out var needsTypeParameter, out var _);
          if (!needsTypeParameter) {
            continue;
          }
        }
        r.Add(ta);
      }
      return r;
    }

    protected List<TypeArgumentInstantiation> ForTypeDescriptors(List<TypeArgumentInstantiation> typeArgs, MemberDecl member, bool lookasideBody) {
      Contract.Requires(member is ConstantField || member is Function || member is Method);
      Contract.Requires(typeArgs != null);
      var memberHasBody =
        (member is ConstantField cf && cf.Rhs != null) ||
        (member is Function f && f.Body != null) ||
        (member is Method m && m.Body != null);
      var r = new List<TypeArgumentInstantiation>();
      foreach (var ta in typeArgs) {
        var tp = ta.Formal;
        if (tp.Parent is TopLevelDeclWithMembers) {
          TypeArgDescriptorUse(member.IsStatic, lookasideBody, (TopLevelDeclWithMembers)member.EnclosingClass, out var _, out var needsTypeDescriptor);
          if (!needsTypeDescriptor) {
            continue;
          }
        }
        r.Add(ta);
      }
      return r;
    }

    /// <summary>
    /// The "additionalCustomParameter" is used when the member is an instance function that requires customer-receiver support.
    /// This parameter is then to be added between any run-time type descriptors and the "normal" arguments. The caller will
    /// arrange for "additionalCustomParameter" to be properly bound.
    /// </summary>
    protected abstract ILvalue EmitMemberSelect(Action<TargetWriter> obj, Type objType, MemberDecl member, List<TypeArgumentInstantiation> typeArgs, Dictionary<TypeParameter, Type> typeMap,
      Type expectedType, string/*?*/ additionalCustomParameter = null, bool internalAccess = false);

    protected void EmitArraySelect(string index, Type elmtType, TargetWriter wr) {
      EmitArraySelect(new List<string>() { index }, elmtType, wr);
    }
    protected abstract TargetWriter EmitArraySelect(List<string> indices, Type elmtType, TargetWriter wr);
    protected abstract TargetWriter EmitArraySelect(List<Expression> indices, Type elmtType, bool inLetExprBody, TargetWriter wr);
    protected virtual ILvalue EmitArraySelectAsLvalue(string array, List<string> indices, Type elmtType) {
      return SimpleLvalue(wr => {
        wr.Write(array);
        EmitArraySelect(indices, elmtType, wr);
      });
    }
    protected virtual TargetWriter EmitArrayUpdate(List<string> indices, string rhs, Type elmtType, TargetWriter wr) {
      var w = EmitArraySelect(indices, elmtType, wr);
      wr.Write(" = {0}", rhs);
      return w;
    }
    protected TargetWriter EmitArrayUpdate(List<string> indices, Expression rhs, TargetWriter wr) {
      var w = new TargetWriter(wr.IndentLevel, true);
      TrExpr(rhs, w, false);
      return EmitArrayUpdate(indices, w.ToString(), rhs.Type, wr);
    }
    protected virtual string ArrayIndexToInt(string arrayIndex, Type fromType) {
      Contract.Requires(arrayIndex != null);
      Contract.Requires(fromType != null);
      return arrayIndex;
    }
    protected virtual string ArrayIndexToNativeInt(string arrayIndex, Type fromType) {
      Contract.Requires(arrayIndex != null);
      Contract.Requires(fromType != null);
      return arrayIndex;
    }
    protected abstract void EmitExprAsInt(Expression expr, bool inLetExprBody, TargetWriter wr);
    protected abstract void EmitIndexCollectionSelect(Expression source, Expression index, bool inLetExprBody, TargetWriter wr);
    protected abstract void EmitIndexCollectionUpdate(Expression source, Expression index, Expression value, CollectionType resultCollectionType, bool inLetExprBody, TargetWriter wr);
    protected virtual void EmitIndexCollectionUpdate(out TargetWriter wSource, out TargetWriter wIndex, out TargetWriter wValue, TargetWriter wr, bool nativeIndex) {
      wSource = wr.Fork();
      wr.Write('[');
      wIndex = wr.Fork();
      wr.Write("] = ");
      wValue = wr.Fork();
    }
    /// <summary>
    /// If "fromArray" is false, then "source" is a sequence.
    /// If "fromArray" is true, then "source" is an array.
    /// </summary>
    protected abstract void EmitSeqSelectRange(Expression source, Expression/*?*/ lo, Expression/*?*/ hi, bool fromArray, bool inLetExprBody, TargetWriter wr);
    protected abstract void EmitSeqConstructionExpr(SeqConstructionExpr expr, bool inLetExprBody, TargetWriter wr);
    protected abstract void EmitMultiSetFormingExpr(MultiSetFormingExpr expr, bool inLetExprBody, TargetWriter wr);
    protected abstract void EmitApplyExpr(Type functionType, Bpl.IToken tok, Expression function, List<Expression> arguments, bool inLetExprBody, TargetWriter wr);
    protected virtual bool TargetLambdaCanUseEnclosingLocals => true;
    protected abstract TargetWriter EmitBetaRedex(List<string> boundVars, List<Expression> arguments, List<Type> boundTypes, Type resultType, Bpl.IToken resultTok, bool inLetExprBody, TargetWriter wr);
    protected virtual void EmitConstructorCheck(string source, DatatypeCtor ctor, TargetWriter wr) {
      wr.Write("{0}.is_{1}", source, ctor.CompileName);
    }
    /// <summary>
    /// EmitDestructor is somewhat similar to following "source" with a call to EmitMemberSelect.
    /// However, EmitDestructor may also need to perform a cast on "source".
    /// Furthermore, EmitDestructor also needs to work for anonymous destructors.
    /// </summary>
    protected abstract void EmitDestructor(string source, Formal dtor, int formalNonGhostIndex, DatatypeCtor ctor, List<Type> typeArgs, Type bvType, TargetWriter wr);
    protected abstract BlockTargetWriter CreateLambda(List<Type> inTypes, Bpl.IToken tok, List<string> inNames, Type resultType, TargetWriter wr, bool untyped = false);

    /// <summary>
    /// Emit an "Immediately Invoked Function Expression" with the semantics of
    ///     var bvName: bvType := <<wrRhs>>; <<wrBody>>
    /// where <<wrBody>> will have type "bodyType". In many languages, this IIFE will not be a "let" expression but a "lambda" expression like this:
    ///     ((bvName: bvType) => <<wrBody>>)(<<wrRhs>>)
    /// </summary>
    protected abstract void CreateIIFE(string bvName, Type bvType, Bpl.IToken bvTok, Type bodyType, Bpl.IToken bodyTok, TargetWriter wr, out TargetWriter wrRhs, out TargetWriter wrBody);
    protected TargetWriter CreateIIFE_ExprBody(string bvName, Type bvType, Bpl.IToken bvTok, Expression rhs, bool inLetExprBody, Type bodyType, Bpl.IToken bodyTok, TargetWriter wr) {
      CreateIIFE(bvName, bvType, bvTok, bodyType, bodyTok, wr, out var wrRhs, out var wrBody);
      TrExpr(rhs, wrRhs, inLetExprBody);
      return wrBody;
    }

    protected abstract BlockTargetWriter CreateIIFE0(Type resultType, Bpl.IToken resultTok, TargetWriter wr);  // Immediately Invoked Function Expression
    protected abstract BlockTargetWriter CreateIIFE1(int source, Type resultType, Bpl.IToken resultTok, string bvName, TargetWriter wr);  // Immediately Invoked Function Expression
    public enum ResolvedUnaryOp { BoolNot, BitwiseNot, Cardinality }
    protected abstract void EmitUnaryExpr(ResolvedUnaryOp op, Expression expr, bool inLetExprBody, TargetWriter wr);

    protected virtual void CompileBinOp(BinaryExpr.ResolvedOpcode op,
      Expression e0, Expression e1, Bpl.IToken tok, Type resultType,
      out string opString,
      out string preOpString,
      out string postOpString,
      out string callString,
      out string staticCallString,
      out bool reverseArguments,
      out bool truncateResult,
      out bool convertE1_to_int,
      TextWriter errorWr) {

      // This default implementation does not handle all cases. It handles some cases that look the same
      // in C-like languages. It also handles cases that can be solved by another operator, but reversing
      // the arguments or following the operation with a negation.
      opString = null;
      preOpString = "";
      postOpString = "";
      callString = null;
      staticCallString = null;
      reverseArguments = false;
      truncateResult = false;
      convertE1_to_int = false;

      BinaryExpr.ResolvedOpcode dualOp = BinaryExpr.ResolvedOpcode.Add;  // NOTE! "Add" is used to say "there is no dual op"
      BinaryExpr.ResolvedOpcode negatedOp = BinaryExpr.ResolvedOpcode.Add;  // NOTE! "Add" is used to say "there is no negated op"

      switch (op) {
        case BinaryExpr.ResolvedOpcode.Iff:
          opString = "=="; break;
        case BinaryExpr.ResolvedOpcode.Imp:
          preOpString = "!"; opString = "||"; break;
        case BinaryExpr.ResolvedOpcode.Or:
          opString = "||"; break;
        case BinaryExpr.ResolvedOpcode.And:
          opString = "&&"; break;
        case BinaryExpr.ResolvedOpcode.BitwiseAnd:
          opString = "&"; break;
        case BinaryExpr.ResolvedOpcode.BitwiseOr:
          opString = "|"; break;
        case BinaryExpr.ResolvedOpcode.BitwiseXor:
          opString = "^"; break;

        case BinaryExpr.ResolvedOpcode.Lt:
        case BinaryExpr.ResolvedOpcode.LtChar:
          opString = "<"; break;
        case BinaryExpr.ResolvedOpcode.Le:
        case BinaryExpr.ResolvedOpcode.LeChar:
          opString = "<="; break;
        case BinaryExpr.ResolvedOpcode.Ge:
        case BinaryExpr.ResolvedOpcode.GeChar:
          opString = ">="; break;
        case BinaryExpr.ResolvedOpcode.Gt:
        case BinaryExpr.ResolvedOpcode.GtChar:
          opString = ">"; break;

        case BinaryExpr.ResolvedOpcode.SetNeq:
          negatedOp = BinaryExpr.ResolvedOpcode.SetEq; break;
        case BinaryExpr.ResolvedOpcode.MultiSetNeq:
          negatedOp = BinaryExpr.ResolvedOpcode.MultiSetEq; break;
        case BinaryExpr.ResolvedOpcode.SeqNeq:
          negatedOp = BinaryExpr.ResolvedOpcode.SeqEq; break;
        case BinaryExpr.ResolvedOpcode.MapNeq:
          negatedOp = BinaryExpr.ResolvedOpcode.MapEq; break;

        case BinaryExpr.ResolvedOpcode.Superset:
          dualOp = BinaryExpr.ResolvedOpcode.Subset; break;
        case BinaryExpr.ResolvedOpcode.MultiSuperset:
          dualOp = BinaryExpr.ResolvedOpcode.MultiSubset; break;

        case BinaryExpr.ResolvedOpcode.ProperSuperset:
          dualOp = BinaryExpr.ResolvedOpcode.ProperSubset; break;
        case BinaryExpr.ResolvedOpcode.ProperMultiSuperset:
          dualOp = BinaryExpr.ResolvedOpcode.ProperMultiSubset; break;

        case BinaryExpr.ResolvedOpcode.NotInSet:
          negatedOp = BinaryExpr.ResolvedOpcode.InSet; break;
        case BinaryExpr.ResolvedOpcode.NotInMultiSet:
          negatedOp = BinaryExpr.ResolvedOpcode.InMultiSet; break;
        case BinaryExpr.ResolvedOpcode.NotInSeq:
          negatedOp = BinaryExpr.ResolvedOpcode.InSeq; break;
        case BinaryExpr.ResolvedOpcode.NotInMap:
          negatedOp = BinaryExpr.ResolvedOpcode.InMap; break;

        default:
          // The operator is one that needs to be handled in the specific compilers.
          Contract.Assert(false); throw new cce.UnreachableException();  // unexpected binary expression
      }

      if (dualOp != BinaryExpr.ResolvedOpcode.Add) {  // remember from above that Add stands for "there is no dual"
        Contract.Assert(negatedOp == BinaryExpr.ResolvedOpcode.Add);
        CompileBinOp(dualOp,
          e1, e0, tok, resultType,
          out opString, out preOpString, out postOpString, out callString, out staticCallString, out reverseArguments, out truncateResult, out convertE1_to_int,
          errorWr);
      } else if (negatedOp != BinaryExpr.ResolvedOpcode.Add) {  // remember from above that Add stands for "there is no negated op"
        CompileBinOp(negatedOp,
          e0, e1, tok, resultType,
          out opString, out preOpString, out postOpString, out callString, out staticCallString, out reverseArguments, out truncateResult, out convertE1_to_int,
          errorWr);
        preOpString = "!" + preOpString;
      }
    }

    protected abstract void EmitIsZero(string varName, TargetWriter wr);
    protected abstract void EmitConversionExpr(ConversionExpr e, bool inLetExprBody, TargetWriter wr);
    protected abstract void EmitCollectionDisplay(CollectionType ct, Bpl.IToken tok, List<Expression> elements, bool inLetExprBody, TargetWriter wr);  // used for sets, multisets, and sequences
    protected abstract void EmitMapDisplay(MapType mt, Bpl.IToken tok, List<ExpressionPair> elements, bool inLetExprBody, TargetWriter wr);

    protected abstract void EmitSetBuilder_New(TargetWriter wr, SetComprehension e, string collectionName);
    protected abstract void EmitMapBuilder_New(TargetWriter wr, MapComprehension e, string collectionName);

    protected abstract void EmitSetBuilder_Add(CollectionType ct, string collName, Expression elmt, bool inLetExprBody, TargetWriter wr);
    protected abstract TargetWriter EmitMapBuilder_Add(MapType mt, Bpl.IToken tok, string collName, Expression term, bool inLetExprBody, TargetWriter wr);

    /// <summary>
    /// The "ct" type is either a SetType or a MapType.
    /// </summary>
    protected abstract string GetCollectionBuilder_Build(CollectionType ct, Bpl.IToken tok, string collName, TargetWriter wr);

    protected virtual void EmitIntegerRange(Type type, out TargetWriter wLo, out TargetWriter wHi, TargetWriter wr) {
      if (AsNativeType(type) != null) {
        wr.Write("{0}.IntegerRange(", IdProtect(type.AsNewtype.FullCompileName));
      } else {
        wr.Write("{0}.IntegerRange(", GetHelperModuleName());
      }
      wLo = wr.Fork();
      wr.Write(", ");
      wHi = wr.Fork();
      wr.Write(')');
    }
    protected abstract void EmitSingleValueGenerator(Expression e, bool inLetExprBody, string type, TargetWriter wr);
    protected virtual void FinishModule() { }

    protected virtual void DeclareExternType(OpaqueTypeDecl d, Expression compileTypeHint, TargetWriter wr) { }

    protected virtual void OrganizeModules(Program program, out List<ModuleDefinition> modules){
      modules = program.CompileModules;
    }

    static public bool ShouldCompileModuleDefinition(ModuleDefinition m) {
      return !(m.IsAbstract // the purpose of an abstract module is to skip compilation
               || m is Functor // We will only compile the results of functor application, not the functors themselves
               || !m.IsToBeCompiled);
    }

    public void Compile(Program program, TargetWriter wrx) {
      Contract.Requires(program != null);

      EmitHeader(program, wrx);
      EmitBuiltInDecls(program.BuiltIns, wrx);
      var temp = new List<ModuleDefinition>();
      OrganizeModules(program, out temp);
      program.CompileModules = temp;
      foreach (ModuleDefinition m in program.CompileModules) {
        if (!ShouldCompileModuleDefinition(m)) { continue; }

        var moduleIsExtern = false;
        string libraryName = null;
        if (!DafnyOptions.O.DisallowExterns) {
          var args = Attributes.FindExpressions(m.Attributes, "extern");
          if (args != null) {
            if (args.Count == 2) {
              libraryName = (string)(args[1] as StringLiteralExpr)?.Value;
            }
            moduleIsExtern = true;
          }
        }
        var wr = CreateModule(m.CompileName, m.IsDefaultModule, moduleIsExtern, libraryName, wrx);
        var v = new CheckHasNoAssumes_Visitor(this, wr);
        foreach (TopLevelDecl d in m.TopLevelDecls) {
          bool compileIt = true;
          if (Attributes.ContainsBool(d.Attributes, "compile", ref compileIt) && !compileIt) {
            continue;
          }
          wr.WriteLine();
          if (d is OpaqueTypeDecl) {
            var at = (OpaqueTypeDecl)d;
            bool externP = Attributes.Contains(at.Attributes, "extern");
            if (externP) {
              var exprs = Attributes.FindExpressions(at.Attributes, "extern");
              Contract.Assert(exprs != null);  // because externP is true
              if (exprs.Count == 1) {
                DeclareExternType(at, exprs[0], wr);
              } else {
                Error(d.tok, "Opaque type ('{0}') with extern attribute requires a compile hint.  Expected {{:extern compile_type_hint}} ", wr, at.FullName);
              }
              v.Visit(exprs);
            } else {
              Error(d.tok, "Opaque type ('{0}') cannot be compiled; perhaps make it a type synonym or use :extern.", wr, at.FullName);
            }
          } else if (d is TypeSynonymDecl) {
            var sst = d as SubsetTypeDecl;
            if (sst != null) {
              DeclareSubsetType(sst, wr);
              v.Visit(sst);
            }
          } else if (d is NewtypeDecl)
          {
            var nt = (NewtypeDecl)d;
            var w = DeclareNewtype(nt, wr);
            v.Visit(nt);
            CompileClassMembers(program, nt, w); 
          }
          else if (d is DatatypeDecl)
          {
            var dt = (DatatypeDecl)d;
            var isGlinear = false;
            /*if (dt is IndDatatypeDecl)
            {
              var idd = dt as IndDatatypeDecl;
              if (idd.Usage.realm == LinearRealm.Erased)
              {
                isGlinear = true;
              }
            }*/

            if (!isGlinear)
            {
              
              CheckForCapitalizationConflicts(dt.Ctors);
              foreach (var ctor in dt.Ctors)
              {
                CheckForCapitalizationConflicts(ctor.Destructors);
              }

              var w = DeclareDatatype(dt, wr);
              if (w != null)
              {
                CompileClassMembers(program, dt, w);
              }
            }
        } else if (d is IteratorDecl) {
            var iter = (IteratorDecl)d;
            if (DafnyOptions.O.ForbidNondeterminism && iter.Outs.Count > 0) {
              Error(iter.tok, "since yield parameters are initialized arbitrarily, iterators are forbidden by /definiteAssignment:3 option", wr);
            }

            var wIter = CreateIterator(iter, wr);
            if (iter.Body == null) {
              Error(iter.tok, "Iterator {0} has no body", wIter, iter.FullName);
            } else {
              TrStmtList(iter.Body.Body, wIter);
            }

          } else if (d is TraitDecl trait) {
            // writing the trait
            var w = CreateTrait(trait.CompileName, trait.IsExtern(out _, out _), trait.TypeArgs, trait.ParentTypeInformation.UniqueParentTraits(), trait.tok, wr);
            CompileClassMembers(program, trait, w);
          } else if (d is ClassDecl cl)
          {
            var include = true;
            if (cl.IsDefaultClass) {
              Predicate<MemberDecl> compilationMaterial = x =>
                !x.IsGhost && (DafnyOptions.O.DisallowExterns || !Attributes.Contains(x.Attributes, "extern"));
              include = cl.Members.Exists(compilationMaterial) || cl.InheritedMembers.Exists(compilationMaterial);
            }
            var classIsExtern = false;
            if (include) {
              classIsExtern = !DafnyOptions.O.DisallowExterns && Attributes.Contains(cl.Attributes, "extern") || cl.IsDefaultClass && Attributes.Contains(cl.EnclosingModuleDefinition.Attributes, "extern");
              if (classIsExtern && cl.Members.TrueForAll(member => member.IsGhost || Attributes.Contains(member.Attributes, "extern"))) {
                include = false;
              }
            }
            if (include) {
              var cw = CreateClass(IdProtect(d.EnclosingModuleDefinition.CompileName), IdName(cl), classIsExtern, cl.FullName,
                cl.TypeArgs, cl, cl.ParentTypeInformation.UniqueParentTraits(), cl.tok, wr);
              CompileClassMembers(program, cl, cw);
              cw.Finish();
            } else {
              // still check that given members satisfy compilation rules
              var abyss = new NullClassWriter();
              CompileClassMembers(program, cl, abyss);
            }
          } else if (d is ValuetypeDecl) {
            // nop
          } else if (d is ModuleDecl) {
            // nop
          } else { Contract.Assert(false); }
        }

        FinishModule();
      }
      EmitFooter(program, wrx);
    }

    protected class NullClassWriter : IClassWriter {
      private readonly TargetWriter abyss = new TargetWriter();
      private readonly BlockTargetWriter block;

      public NullClassWriter() {
        block = abyss.NewBlock("");
      }

      public BlockTargetWriter/*?*/ CreateMethod(Method m, List<TypeArgumentInstantiation> typeArgs, bool createBody, bool forBodyInheritance, bool lookasideBody) {
        return createBody ? block : null;
      }
      public BlockTargetWriter/*?*/ CreateFunction(string name, List<TypeArgumentInstantiation> typeArgs, List<Formal> formals, Type resultType, Usage resultUsage, Bpl.IToken tok, bool isStatic, bool createBody, MemberDecl member, bool forBodyInheritance, bool lookasideBody) {
        return createBody ? block : null;
      }
      public BlockTargetWriter/*?*/ CreateGetter(string name, TopLevelDecl enclosingDecl, Type resultType, Bpl.IToken tok, bool isStatic, bool isConst, bool createBody, MemberDecl/*?*/ member, bool forBodyInheritance) {
        return createBody ? block : null;
      }
      public BlockTargetWriter/*?*/ CreateGetterSetter(string name, Type resultType, Bpl.IToken tok, bool isStatic, bool createBody, MemberDecl/*?*/ member, out TargetWriter setterWriter, bool forBodyInheritance) {
        if (createBody) {
          setterWriter = block;
          return block;
        } else {
          setterWriter = null;
          return null;
        }
      }
      public void DeclareField(string name, TopLevelDecl enclosingDecl, bool isStatic, bool isConst, Type type, Bpl.IToken tok, string rhs, Field field) { }

      public void InitializeField(Field field, Type instantiatedFieldType, TopLevelDeclWithMembers enclosingClass) { }

      public TextWriter/*?*/ ErrorWriter() {
        return null; // match the old behavior of Compile() where this is used
      }

      public void Finish() { }
    }

    protected void ReadRuntimeSystem(string filename, TextWriter wr) {
      Contract.Requires(filename != null);
      Contract.Requires(wr != null);

      if (DafnyOptions.O.UseRuntimeLib) {
        return;
      }
      var assemblyLocation = System.Reflection.Assembly.GetExecutingAssembly().Location;
      Contract.Assert(assemblyLocation != null);
      var codebase = System.IO.Path.GetDirectoryName(assemblyLocation);
      Contract.Assert(codebase != null);
      string path = System.IO.Path.Combine(codebase, filename);
      WriteFromFile(path, wr);
    }

    protected void WriteFromFile(string inputFilename, TextWriter outputWriter) {
      using (var rd = new StreamReader(new FileStream(inputFilename, System.IO.FileMode.Open, System.IO.FileAccess.Read))) {
        while (true) {
          string s = rd.ReadLine();
          if (s == null) {
            return;
          }
          outputWriter.WriteLine(s);
        }
      }
    }

    // create a varName that is not a duplicate of formals' name
    protected string GenVarName(string root, List<Formal> formals) {
      bool finished = false;
      while (!finished) {
        finished = true;
        int i = 0;
        foreach (var arg in formals) {
          if (!arg.IsGhost) {
            // FormalName returns a protected name, so we compare a protected version of "root" to it
            if (IdProtect(root).Equals(FormalName(arg, i))) {
              root += root;
              finished = false;
            }
            i++;
          }
        }
      }
      return root;
    }

    protected int WriteFormals(string sep, List<Formal> formals, TextWriter wr, List<Formal>/*?*/ useTheseNamesForFormals = null) {
      Contract.Requires(sep != null);
      Contract.Requires(formals != null);
      Contract.Requires(wr != null);
      Contract.Requires(useTheseNamesForFormals == null || useTheseNamesForFormals.Count == formals.Count);

      int n = 0;
      for (var i = 0; i < formals.Count; i++) {
        var arg = formals[i];
        if (!arg.IsReallyGhost) {
          string name = FormalName(useTheseNamesForFormals == null ? arg : useTheseNamesForFormals[i], n);
          if (DeclareFormal(sep, name, arg.Type, arg.tok, arg.Usage, arg.InParam | arg.Inout, arg.Inout, wr)) {
            sep = ", ";
          }
          n++;
        }
      }
      return n;  // the number of formals written
    }

    protected string FormalName(Formal formal, int i) {
      Contract.Requires(formal != null);
      Contract.Ensures(Contract.Result<string>() != null);

      return IdProtect(formal.HasName ? formal.CompileName : "_a" + i);
    }

    public bool HasMain(Program program, out Method mainMethod) {
      Contract.Ensures(Contract.Result<bool>() == (Contract.ValueAtReturn(out mainMethod) != null));
      mainMethod = null;
      bool hasMain = false;
      string name = DafnyOptions.O.MainMethod;
      if (name != null && name == "-") return false;
      if (name != null && name != "") {
        foreach (var module in program.CompileModules) {
          if (module.IsAbstract) {
            // the purpose of an abstract module is to skip compilation
            continue;
          }
          foreach (var decl in module.TopLevelDecls) {
            if (decl is TopLevelDeclWithMembers c) {
              foreach (MemberDecl member in c.Members) {
                if (member is Method m && member.FullDafnyName == name) {
                  mainMethod = m;
                  if (!IsPermittedAsMain(mainMethod, out string reason)) {
                    Error(mainMethod.tok, "The method \"{0}\" is not permitted as a main method ({1}).", null, name, reason);
                    mainMethod = null;
                    return false;
                  } else {
                    return true;
                  }
                }
              }
            }
          }
        }
        Error(program.DefaultModule.tok, "Could not find the method named by the -Main option: {0}", null, name);
      }
      foreach (var module in program.CompileModules) {
        if (module.IsAbstract) {
          // the purpose of an abstract module is to skip compilation
          continue;
        }
        foreach (var decl in module.TopLevelDecls) {
          var c = decl as TopLevelDeclWithMembers;
          if (c != null) {
            foreach (var member in c.Members) {
              var m = member as Method;
              if (m != null && Attributes.Contains(m.Attributes, "main")) {
                if (mainMethod == null) {
                  mainMethod = m;
                  hasMain = true;
                } else {
                  // more than one main in the program
                  Error(m.tok, "More than one method is marked \"{{:main}}\". First declaration appeared at {0}.", null,
                    ErrorReporter.TokenToString(mainMethod.tok));
                  hasMain = false;
                }
              }
            }
          }
        }
      }
      if (hasMain) {
        if (!IsPermittedAsMain(mainMethod, out string reason)) {
          Error(mainMethod.tok, "This method marked \"{{:main}}\" is not permitted as a main method ({0}).", null, reason);
          mainMethod = null;
          return false;
        } else {
          return true;
        }
      }
      if (mainMethod != null) {
        mainMethod = null;
        return false;
      }

      mainMethod = null;
      foreach (var module in program.CompileModules) {
        if (module.IsAbstract) {
          // the purpose of an abstract module is to skip compilation
          continue;
        }
        foreach (var decl in module.TopLevelDecls) {
          var c = decl as TopLevelDeclWithMembers;
          if (c != null) {
            foreach (var member in c.Members) {
              var m = member as Method;
              if (m != null && m.Name == DefaultNameMain) {
                if (mainMethod == null) {
                  mainMethod = m;
                  hasMain = true;
                } else {
                  // more than one main in the program
                  Error(m.tok, "More than one method is declared as \"{0}\". First declaration appeared at {1}.", null,
                    DefaultNameMain, ErrorReporter.TokenToString(mainMethod.tok));
                  hasMain = false;
                }
              }
            }
          }
        }
      }

      if (hasMain) {
        if (!IsPermittedAsMain(mainMethod, out string reason)) {
          Error(mainMethod.tok, "This method \"Main\" is not permitted as a main method ({0}).", null, reason);
          return false;
        } else {
          return true;
        }
      } else {
        // make sure "mainMethod" returns as null
        mainMethod = null;
        return false;
      }
    }

    public static bool IsPermittedAsMain(Method m, out String reason) {
      Contract.Requires(m.EnclosingClass is TopLevelDeclWithMembers);
      // In order to be a legal Main() method, the following must be true:
      //    The method is not a ghost method
      //    The method takes no non-ghost parameters and no type parameters
      //    The enclosing type does not take any type parameters
      //    If the method is an instance (that is, non-static) method in a class, then the enclosing class must not declare any constructor
      // In addition, either:
      //    The method is called "Main"
      //    The method has no requires clause
      //    The method has no modifies clause
      // or:
      //    The method is annotated with {:main}
      // Note, in the case where the method is annotated with {:main}, the method is allowed to have preconditions and modifies clauses.
      // This lets the programmer add some explicit assumptions about the outside world, modeled, for example, via ghost parameters.
      var cl = (TopLevelDeclWithMembers)m.EnclosingClass;
      if (m.IsGhost) {
        reason = "the method is ghost";
        return false;
      }
      if (m.Usage.realm == LinearRealm.Erased) {
        reason = "the method is glinear";
        return false;
      }
      if (m.TypeArgs.Count != 0) {
        reason = "the method has type parameters";
        return false;
      }
      if (cl is OpaqueTypeDecl) {
        reason = "the enclosing type is an opaque type";
        return false;
      }
      if (!m.IsStatic) {
        if (cl is TraitDecl) {
          reason = "the method is not static and the enclosing type does not support auto-initialization";
          return false;
        } else if (cl is ClassDecl) {
          if (cl.Members.Exists(f => f is Constructor)) {
            reason = "the method is not static and the enclosing class has constructors";
            return false;
          }
        } else {
          var ty = UserDefinedType.FromTopLevelDeclWithAllBooleanTypeParameters(cl);
          if (!ty.HasCompilableValue) {
            reason = "the method is not static and the enclosing type does not support auto-initialization";
            return false;
          }
        }
      }
      if (!m.Ins.TrueForAll(f => f.IsGhost)) {
        reason = "the method has non-ghost parameters";
        return false;
      }
      if (!m.Outs.TrueForAll(f => f.IsGhost)) {
        reason = "the method has non-ghost out parameters";
        return false;
      }
      if (Attributes.Contains(m.Attributes, "main")) {
        reason = "";
        return true;
      }
      if (m.Req.Count != 0)
      {
        reason = "the method has requires clauses";
        return false;
      }
      if (m.Mod.Expressions.Count != 0) {
        reason = "the method has modifies clauses";
        return false;
      }
      reason = "";
      return true;
    }

    void OrderedBySCC(List<MemberDecl> decls, TopLevelDeclWithMembers c) {
      List<ConstantField> consts = new List<ConstantField>();
      foreach (var decl in decls) {
        if (decl is ConstantField) {
          consts.Add((ConstantField)decl);
        }
      }
      consts.Sort((a, b) => c.EnclosingModuleDefinition.CallGraph.GetSCCRepresentativeId(a) - c.EnclosingModuleDefinition.CallGraph.GetSCCRepresentativeId(b));
      foreach (var con in consts) {
        decls.Remove(con);
      }
      decls.AddRange(consts);
    }

    public static bool NeedsCustomReceiver(MemberDecl member) {
      Contract.Requires(member != null);
      if (!member.IsStatic && member.EnclosingClass is NewtypeDecl) {
        return true;
      } else if (!member.IsStatic && member.EnclosingClass is TraitDecl) {
        if (member is ConstantField cf && cf.Rhs != null) {
          return true;
        } else if (member is Function f && f.Body != null) {
          return true;
        } else if (member is Method m && m.Body != null) {
          return true;
        }
      }
      return false;
    }

    void CompileClassMembers(Program program, TopLevelDeclWithMembers c, IClassWriter classWriter) {
      Contract.Requires(c != null);
      Contract.Requires(classWriter != null);
      Contract.Requires(thisContext == null);
      Contract.Ensures(thisContext == null);

      var errorWr = classWriter.ErrorWriter();
      var v = new CheckHasNoAssumes_Visitor(this, errorWr);

      if (c is ClassDecl) {
        CheckHandleWellformed((ClassDecl)c, errorWr);
      }

      var inheritedMembers = c.InheritedMembers;
      CheckForCapitalizationConflicts(c.Members, inheritedMembers);
      OrderedBySCC(inheritedMembers, c);
      OrderedBySCC(c.Members, c);

      if (!(c is TraitDecl) || TraitRepeatsInheritedDeclarations) {
        thisContext = c;
        foreach (var member in inheritedMembers) {
          Contract.Assert(!member.IsStatic);  // only instance members should ever be added to .InheritedMembers
          if (member.IsGhost) {
            // skip
          } else if (c is TraitDecl) {
            RedeclareInheritedMember(member, classWriter);
          } else if (member is ConstantField) {
            var cf = (ConstantField)member;
            var cfType = Resolver.SubstType(cf.Type, c.ParentFormalTypeParametersToActuals);
            if (cf.Rhs == null) {
              Contract.Assert(!cf.IsStatic); // as checked above, only instance members can be inherited
              classWriter.DeclareField("_" + cf.CompileName, c, false, false, cfType, cf.tok, PlaceboValue(cfType, errorWr, cf.tok, Usage.Ordinary, true), cf);
            }
            var w = CreateFunctionOrGetter(cf, IdName(cf), c, false, true, true, classWriter);
            Contract.Assert(w != null);  // since the previous line asked for a body
            if (cf.Rhs == null) {
              var sw = EmitReturnExpr(w, false);
              sw = EmitCoercionIfNecessary(cfType, cf.Type, cf.tok, sw);
              // get { return this._{0}; }
              EmitThis(sw);
              sw.Write("._{0}", cf.CompileName);
            } else {
              EmitCallToInheritedConstRHS(cf, w);
            }
          } else if (member is Field f) {
            var fType = Resolver.SubstType(f.Type, c.ParentFormalTypeParametersToActuals);
            // every field is inherited
            classWriter.DeclareField("_" + f.CompileName, c, false, false, fType, f.tok, PlaceboValue(fType, errorWr, f.tok, Usage.Ordinary, true), f);
            TargetWriter wSet;
            var wGet = classWriter.CreateGetterSetter(IdName(f), f.Type, f.tok, false, true, member, out wSet, true);
            {
              var sw = EmitReturnExpr(wGet, false);
              sw = EmitCoercionIfNecessary(fType, f.Type, f.tok, sw);
              // get { return this._{0}; }
              EmitThis(sw);
              sw.Write("._{0}", f.CompileName);
            }
            {
              // set { this._{0} = value; }
              EmitThis(wSet);
              wSet.Write("._{0}", f.CompileName);
              var sw = EmitAssignmentRhs(wSet);
              sw = EmitCoercionIfNecessary(f.Type, fType, f.tok, sw);
              EmitSetterParameter(sw);
            }
          } else if (member is Function fn) {
            Contract.Assert(fn.Body != null);
            var w = classWriter.CreateFunction(IdName(fn), CombineAllTypeArguments(fn), fn.Formals, fn.ResultType, Usage.Ordinary, fn.tok, fn.IsStatic, true, fn, true, false);
            EmitCallToInheritedFunction(fn, w);
          } else if (member is Method method) {
            Contract.Assert(method.Body != null);
            var w = classWriter.CreateMethod(method, CombineAllTypeArguments(member), true, true, false);
            EmitCallToInheritedMethod(method, w);
          } else {
            Contract.Assert(false);  // unexpected member
          }
        }
        thisContext = null;
      }

      foreach (MemberDecl member in c.Members) {
        if (!member.IsStatic) {
          thisContext = c;
        }
        if (c is TraitDecl && member.OverriddenMember != null && !member.IsOverrideThatAddsBody) {
          if (TraitRepeatsInheritedDeclarations) {
            RedeclareInheritedMember(member, classWriter);
          } else {
            // emit nothing in the trait; this member will be emitted in the classes that extend this trait
          }
        } else if (member is Field) {
          var f = (Field)member;
          if (f.IsGhost) {
            // emit nothing
          } else if (!DafnyOptions.O.DisallowExterns && Attributes.Contains(f.Attributes, "extern")) {
            // emit nothing
          } else if (f is ConstantField) {
            var cf = (ConstantField)f;
            if (cf.IsStatic && !SupportsStaticsInGenericClasses && cf.EnclosingClass.TypeArgs.Count != 0) {
              var wBody = classWriter.CreateFunction(IdName(cf), CombineAllTypeArguments(cf), new List<Formal>(), cf.Type, f.Usage, cf.tok, true, true, member, false, false);
              Contract.Assert(wBody != null);  // since the previous line asked for a body
              if (cf.Rhs != null) {
                CompileReturnBody(cf.Rhs, f.Type, wBody, null, false);
              } else {
                EmitReturnExpr(PlaceboValue(cf.Type, wBody, cf.tok, Usage.Ordinary, true), wBody, false);
              }
            } else {
              BlockTargetWriter wBody;
              if (cf.IsStatic) {
                wBody = CreateFunctionOrGetter(cf, IdName(cf), c, true, true, false, classWriter);
                Contract.Assert(wBody != null);  // since the previous line asked for a body
              } else if (NeedsCustomReceiver(cf)) {
                // An instance field in a newtype needs to be modeled as a static function that takes a parameter,
                // because a newtype value is always represented as some existing type.
                // Likewise, an instance const with a RHS in a trait needs to be modeled as a static function (in the companion class)
                // that takes a parameter, because trait-equivalents in target languages don't allow implementations.
                wBody = classWriter.CreateFunction(IdName(cf), CombineAllTypeArguments(cf), new List<Formal>(), cf.Type, Usage.Ordinary, cf.tok, true, true, cf, false, true);
                Contract.Assert(wBody != null);  // since the previous line asked for a body
                if (c is TraitDecl) {
                  // also declare a function for the field in the interface
                  var wBodyInterface = CreateFunctionOrGetter(cf, IdName(cf), c, false, false, false, classWriter);
                  Contract.Assert(wBodyInterface == null);  // since the previous line said not to create a body
                }
              } else if (c is TraitDecl) {
                wBody = CreateFunctionOrGetter(cf, IdName(cf), c, false, false, false, classWriter);
                Contract.Assert(wBody == null);  // since the previous line said not to create a body
              } else if (cf.Rhs == null && c is ClassDecl) {
                // create a backing field, since this constant field may be assigned in constructors
                classWriter.DeclareField("_" + f.CompileName, c, false, false, f.Type, f.tok, PlaceboValue(f.Type, errorWr, f.tok, Usage.Ordinary, true), f);
                wBody = CreateFunctionOrGetter(cf, IdName(cf), c, false, true, false, classWriter);
                Contract.Assert(wBody != null);  // since the previous line asked for a body
              } else {
                wBody = CreateFunctionOrGetter(cf, IdName(cf), c, false, true, false, classWriter);
                Contract.Assert(wBody != null);  // since the previous line asked for a body
              }
              if (wBody != null) {
                if (cf.Rhs != null) {
                  CompileReturnBody(cf.Rhs, cf.Type, wBody, null, false);
                } else if (!cf.IsStatic && c is ClassDecl) {
                  var sw = EmitReturnExpr(wBody, false);
                  var typeSubst = new Dictionary<TypeParameter, Type>();
                  cf.EnclosingClass.TypeArgs.ForEach(tp => typeSubst.Add(tp, (Type)new UserDefinedType(tp)));
                  var typeArgs = CombineAllTypeArguments(cf);
                  EmitMemberSelect(EmitThis, UserDefinedType.FromTopLevelDecl(c.tok, c), cf,
                    typeArgs, typeSubst, f.Type, internalAccess: true).EmitRead(sw);
                } else {
                  EmitReturnExpr(PlaceboValue(cf.Type, wBody, cf.tok, Usage.Ordinary, true), wBody, false);
                }
              }
            }
          } else if (c is TraitDecl) {
            TargetWriter wSet;
            var wGet = classWriter.CreateGetterSetter(IdName(f), f.Type, f.tok, f.IsStatic, false, member, out wSet, false);
            Contract.Assert(wSet == null && wGet == null);  // since the previous line specified no body
          } else {
            var rhs = c is TraitDecl ? null : PlaceboValue(f.Type, errorWr, f.tok, Usage.Ordinary, true);
            classWriter.DeclareField(IdName(f), c, f.IsStatic, false, f.Type, f.tok, rhs, f);
          }
          if (f is ConstantField && ((ConstantField)f).Rhs != null) {
            v.Visit(((ConstantField)f).Rhs);
          }
        } else if (member is Function) {
          var f = (Function)member;
          if (f.Body == null && !(c is TraitDecl && !f.IsStatic) &&
              !(!DafnyOptions.O.DisallowExterns && (Attributes.Contains(f.Attributes, "dllimport") || (IncludeExternMembers && Attributes.Contains(f.Attributes, "extern"))))) {
            // A (ghost or non-ghost) function must always have a body, except if it's an instance function in a trait.
            if (Attributes.Contains(f.Attributes, "axiom") || (!DafnyOptions.O.DisallowExterns && Attributes.Contains(f.Attributes, "extern"))) {
              // suppress error message
            } else {
              Error(f.tok, "Function {0} has no body", errorWr, f.FullName);
            }
          } else if (f.IsGhost) {
            // nothing to compile, but we do check for assumes
            if (f.Body == null) {
              Contract.Assert(c is TraitDecl && !f.IsStatic || Attributes.Contains(f.Attributes, "extern"));
            }

            if (Attributes.Contains(f.Attributes, "test")) {
              Error(f.tok, "Function {0} must be compiled to use the {{:test}} attribute", errorWr, f.FullName);
            }
          } else if (f.ResultUsage.realm == LinearRealm.Erased) {
            // do nothing
          } else if (c is TraitDecl && !f.IsStatic) {
            if (f.OverriddenMember == null) {
              var w = classWriter.CreateFunction(IdName(f), CombineAllTypeArguments(f), f.Formals, f.ResultType, f.ResultUsage, f.tok, false, false, f, false, false);
              Contract.Assert(w == null); // since we requested no body
            } else if (TraitRepeatsInheritedDeclarations) {
              RedeclareInheritedMember(f, classWriter);
            }
            if (f.Body != null) {
              CompileFunction(f, classWriter, true);
            }
          } else {
            CompileFunction(f, classWriter, false);
          }
          v.Visit(f);
        } else if (member is Method m) {
          if (m.Body == null && !(c is TraitDecl && !m.IsStatic) &&
              !(!DafnyOptions.O.DisallowExterns && (Attributes.Contains(m.Attributes, "dllimport") || (IncludeExternMembers && Attributes.Contains(m.Attributes, "extern"))))) {
            // A (ghost or non-ghost) method must always have a body, except if it's an instance method in a trait.
            if (Attributes.Contains(m.Attributes, "axiom") || (!DafnyOptions.O.DisallowExterns && Attributes.Contains(m.Attributes, "extern"))) {
              // suppress error message
            } else {
              Error(m.tok, "Method {0} has no body", errorWr, m.FullName);
            }
          } else if (m.IsGhost)
          {
            if (m.Body == null)
            {
              Contract.Assert(c is TraitDecl && !m.IsStatic);
            }
          } else if (m.Usage.realm == LinearRealm.Erased) {
            // do nothing
          } else if (c is TraitDecl && !m.IsStatic) {
            if (m.OverriddenMember == null) {
              var w = classWriter.CreateMethod(m, CombineAllTypeArguments(m), false, false, false);
              Contract.Assert(w == null);  // since we requested no body
            } else if (TraitRepeatsInheritedDeclarations) {
              RedeclareInheritedMember(m, classWriter);
            }
            if (m.Body != null) {
              CompileMethod(program, m, classWriter, true);
            }
          } else {
            CompileMethod(program, m, classWriter, false);
          }
          v.Visit(m);
        } else {
          Contract.Assert(false); throw new cce.UnreachableException();  // unexpected member
        }

        thisContext = null;
      }
    }

    protected BlockTargetWriter /*?*/ CreateFunctionOrGetter(ConstantField cf, string name, TopLevelDecl enclosingDecl, bool isStatic,
      bool createBody, bool forBodyInheritance, IClassWriter classWriter) {
      var typeArgs = CombineAllTypeArguments(cf);
      var typeDescriptors = ForTypeDescriptors(typeArgs, cf, false);
      if (NeedsTypeDescriptors(typeDescriptors)) {
        return classWriter.CreateFunction(name, typeArgs, new List<Formal>(), cf.Type, cf.Usage, cf.tok, isStatic, createBody, cf, forBodyInheritance, false);
      } else {
        return classWriter.CreateGetter(name, enclosingDecl, cf.Type, cf.tok, isStatic, true, createBody, cf, forBodyInheritance);
      }
    }

    private void RedeclareInheritedMember(MemberDecl member, IClassWriter classWriter) {
      Contract.Requires(member != null);
      Contract.Requires(classWriter != null);

      if (member is ConstantField cf) {
        var wBody = CreateFunctionOrGetter(cf, IdName(cf), member.EnclosingClass, false, false, false, classWriter);
        Contract.Assert(wBody == null); // since the previous line said not to create a body
      } else if (member is Field field) {
        TargetWriter wSet;
        var wGet = classWriter.CreateGetterSetter(IdName(field), field.Type, field.tok, false, false, member, out wSet, false);
        Contract.Assert(wGet == null && wSet == null); // since the previous line said not to create a body
      } else if (member is Function) {
        var fn = ((Function)member).Original;
        var wBody = classWriter.CreateFunction(IdName(fn), CombineAllTypeArguments(fn), fn.Formals, fn.ResultType, fn.Usage, fn.tok, fn.IsStatic, false, fn, false, false);
        Contract.Assert(wBody == null); // since the previous line said not to create a body
      } else if (member is Method) {
        var method = ((Method)member).Original;
        var wBody = classWriter.CreateMethod(method, CombineAllTypeArguments(method), false, false, false);
        Contract.Assert(wBody == null); // since the previous line said not to create a body
      } else {
        Contract.Assert(false); // unexpected member
      }
    }

    protected void EmitCallToInheritedConstRHS(ConstantField f, TargetWriter wr) {
      Contract.Requires(f != null);
      Contract.Requires(!f.IsStatic);
      Contract.Requires(f.EnclosingClass is TraitDecl);
      Contract.Requires(f.Rhs != null);
      Contract.Requires(wr != null);
      Contract.Requires(thisContext != null);

      var fOriginal = f;

      // In a target language that requires type coercions, the function declared in "thisContext" has
      // the same signature as in "fOriginal.EnclosingClass".
      wr = EmitReturnExpr(wr, false);
      wr = EmitCoercionIfNecessary(f.Type, fOriginal.Type, f.tok, wr);

      var calleeReceiverType = Resolver.SubstType(UserDefinedType.FromTopLevelDecl(f.tok, f.EnclosingClass), thisContext.ParentFormalTypeParametersToActuals);
      wr.Write("{0}{1}", TypeName_Companion(calleeReceiverType, wr, f.tok, f), ModuleSeparator);
      var typeArgs = CombineAllTypeArguments(f, thisContext);
      EmitNameAndActualTypeArgs(IdName(f), TypeArgumentInstantiation.ToActuals(ForTypeParameters(typeArgs, f, true)), f.tok, wr);
      wr.Write("(");
      var sep = "";
      EmitTypeDescriptorsActuals(ForTypeDescriptors(typeArgs, f, true), f.tok, wr, ref sep);

      wr.Write(sep);
      var w = EmitCoercionIfNecessary(UserDefinedType.FromTopLevelDecl(f.tok, thisContext), calleeReceiverType, f.tok, wr);
      EmitThis(w);
      wr.Write(")");
    }

    protected void EmitCallToInheritedFunction(Function f, TargetWriter wr) {
      Contract.Requires(f != null);
      Contract.Requires(!f.IsStatic);
      Contract.Requires(f.EnclosingClass is TraitDecl);
      Contract.Requires(f.Body != null);
      Contract.Requires(wr != null);
      Contract.Requires(thisContext != null);

      // There are three types involved.
      // First, "f.Original.EnclosingClass" is the trait where the function was first declared.
      // In descendant traits from there on, the function may occur several times, each time with
      // a strengthening of the specification. Those traits do no play a role here.
      // Second, there is "f.EnclosingClass", which is the trait where the function is given a body.
      // Often, "f.EnclosingClass" and "f.Original.EnclosingClass" will be the same.
      // Third and finally, there is "thisContext", which is the class that inherits "f" and its
      // implementation, and for which we're about to generate a call to body compiled for "f".

      // In a target language that requires type coercions, the function declared in "thisContext" has
      // the same signature as in "f.Original.EnclosingClass".
      wr = EmitReturnExpr(wr, false);
      wr = EmitCoercionIfNecessary(f.ResultType, f.Original.ResultType, f.tok, wr);

      var calleeReceiverType = Resolver.SubstType(UserDefinedType.FromTopLevelDecl(f.tok, f.EnclosingClass), thisContext.ParentFormalTypeParametersToActuals);
      wr.Write("{0}{1}", TypeName_Companion(calleeReceiverType, wr, f.tok, f), ModuleSeparator);
      var typeArgs = CombineAllTypeArguments(f, thisContext);
      EmitNameAndActualTypeArgs(IdName(f), TypeArgumentInstantiation.ToActuals(ForTypeParameters(typeArgs, f, true)), f.tok, wr);
      wr.Write("(");
      var sep = "";
      EmitTypeDescriptorsActuals(ForTypeDescriptors(typeArgs, f, true), f.tok, wr, ref sep);

      wr.Write(sep);
      var w = EmitCoercionIfNecessary(UserDefinedType.FromTopLevelDecl(f.tok, thisContext), calleeReceiverType, f.tok, wr);
      EmitThis(w);
      sep = ", ";

      for (int j = 0, l = 0; j < f.Formals.Count; j++) {
        var p = f.Formals[j];
        if (!p.IsReallyGhost) {
          wr.Write(sep);
          w = EmitCoercionIfNecessary(f.Original.Formals[j].Type, f.Formals[j].Type, f.tok, wr);
          w.Write(IdName(p));
          sep = ", ";
          l++;
        }
      }
      wr.Write(")");
    }

    protected void EmitCallToInheritedMethod(Method method, BlockTargetWriter wr) {
      Contract.Requires(method != null);
      Contract.Requires(!method.IsStatic);
      Contract.Requires(method.EnclosingClass is TraitDecl);
      Contract.Requires(method.Body != null);
      Contract.Requires(wr != null);
      Contract.Requires(thisContext != null);

      // There are three types involved. See comment in EmitCallToInheritedFunction.

      var nonGhostOutParameterCount = method.Outs.Count(p => !p.IsReallyGhost);
      var returnStyleOuts = UseReturnStyleOuts(method, nonGhostOutParameterCount);
      var returnStyleOutCollector = nonGhostOutParameterCount > 1 && returnStyleOuts && !SupportsMultipleReturns ? idGenerator.FreshId("_outcollector") : null;

      var outTmps = new List<string>();  // contains a name for each non-ghost formal out-parameter
      var outTypes = new List<Type>();  // contains a type for each non-ghost formal out-parameter
      for (int i = 0; i < method.Outs.Count; i++) {
        Formal p = method.Outs[i];
        if (!p.IsReallyGhost) {
          var target = returnStyleOutCollector != null ? IdName(p) : idGenerator.FreshId("_out");
          outTmps.Add(target);
          outTypes.Add(p.Type);
          DeclareLocalVar(target, p.Type, p.tok, p.Usage, false, null, wr, true);
        }
      }
      Contract.Assert(outTmps.Count == nonGhostOutParameterCount && outTypes.Count == nonGhostOutParameterCount);

      if (returnStyleOutCollector != null) {
        DeclareSpecificOutCollector(returnStyleOutCollector, wr, outTypes, outTypes);
      } else if (nonGhostOutParameterCount > 0 && returnStyleOuts) {
        wr.Write("{0} = ", Util.Comma(outTmps));
      }

      var protectedName = IdName(method);
      var calleeReceiverType = Resolver.SubstType(UserDefinedType.FromTopLevelDecl(method.tok, method.EnclosingClass), thisContext.ParentFormalTypeParametersToActuals);
      wr.Write(TypeName_Companion(calleeReceiverType, wr, method.tok, method));
      wr.Write(ClassAccessor);

      var typeArgs = CombineAllTypeArguments(method, thisContext);
      EmitNameAndActualTypeArgs(protectedName, TypeArgumentInstantiation.ToActuals(ForTypeParameters(typeArgs, method, true)), method.tok, wr);
      wr.Write("(");
      var sep = "";
      EmitTypeDescriptorsActuals(ForTypeDescriptors(typeArgs, method, true), method.tok, wr, ref sep);

      wr.Write(sep);
      var w = EmitCoercionIfNecessary(UserDefinedType.FromTopLevelDecl(method.tok, thisContext), calleeReceiverType, method.tok, wr);
      EmitThis(w);
      sep = ", ";

      for (int j = 0, l = 0; j < method.Ins.Count; j++) {
        var p = method.Ins[j];
        if (!p.IsReallyGhost) {
          wr.Write(sep);
          w = EmitCoercionIfNecessary(method.Original.Ins[j].Type, method.Ins[j].Type, method.tok, wr);
          w.Write(IdName(p));
          sep = ", ";
          l++;
        }
      }

      if (!returnStyleOuts) {
        foreach (var outTmp in outTmps) {
          wr.Write(sep);
          EmitActualOutArg(outTmp, wr);
          sep = ", ";
        }
      }
      wr.Write(')');
      EndStmt(wr);

      if (returnStyleOutCollector != null) {
        EmitCastOutParameterSplits(returnStyleOutCollector, outTmps, wr, outTypes, outTypes, method.tok);
        EmitReturn(method.Outs, wr);
      } else if (!returnStyleOuts) {
        for (int j = 0, l = 0; j < method.Outs.Count; j++) {
          var p = method.Outs[j];
          if (!p.IsReallyGhost) {
            EmitAssignment(IdName(p), method.Outs[j].Type, outTmps[l], outTypes[l], wr);
            l++;
          }
        }
      } else {
        var wrReturn = EmitReturnExpr(wr, false);
        sep = "";
        for (int j = 0, l = 0; j < method.Outs.Count; j++) {
          var p = method.Outs[j];
          if (!p.IsReallyGhost) {
            wrReturn.Write(sep);
            w = EmitCoercionIfNecessary(method.Outs[j].Type, outTypes[l], method.tok, wrReturn);
            w.Write(outTmps[l]);
            sep = ", ";
            l++;
          }
        }
      }
    }

    protected List<TypeArgumentInstantiation> CombineAllTypeArguments(MemberDecl member) {
      Contract.Requires(member != null);
      var classActuals = member.EnclosingClass.TypeArgs.ConvertAll(tp => (Type)new UserDefinedType(tp));
      var memberActuals = member is ICallable ic ? ic.TypeArgs.ConvertAll(tp => (Type)new UserDefinedType(tp)) : null;
      return CombineAllTypeArguments(member, classActuals, memberActuals);
    }

    protected List<TypeArgumentInstantiation> CombineAllTypeArguments(MemberDecl member, TopLevelDeclWithMembers receiverContext) {
      Contract.Requires(member is ICallable);
      Contract.Requires(receiverContext != null);
      var classActuals = member.EnclosingClass.TypeArgs.ConvertAll(tp => receiverContext.ParentFormalTypeParametersToActuals[tp]);
      var memberActuals = ((ICallable)member).TypeArgs.ConvertAll(tp => (Type)new UserDefinedType(tp));
      return CombineAllTypeArguments(member, classActuals, memberActuals);
    }

    protected List<TypeArgumentInstantiation> CombineAllTypeArguments(MemberDecl member, List<Type> typeArgsEnclosingClass, List<Type> typeArgsMember) {
      Contract.Requires(member != null);
      Contract.Requires(typeArgsEnclosingClass != null);
      Contract.Requires(typeArgsMember != null);

      return TypeArgumentInstantiation.ListFromMember(member, typeArgsEnclosingClass, typeArgsMember);
    }

    protected int WriteRuntimeTypeDescriptorsFormals(MemberDecl member, List<TypeArgumentInstantiation> typeParams,
      TargetWriter wr, ref string prefix, Func<TypeParameter, string> formatter) {
      Contract.Requires(member != null);
      Contract.Requires(typeParams != null);
      Contract.Requires(prefix != null);
      Contract.Requires(wr != null);
      Contract.Ensures(Contract.ValueAtReturn(out prefix) != null);

      var c = 0;
      foreach (var ta in typeParams) {
        var tp = ta.Formal;
        if (NeedsTypeDescriptor(tp)) {
          wr.Write($"{prefix}{formatter(tp)}");
          prefix = ", ";
          c++;
        }
      }
      return c;
    }

    void CheckHandleWellformed(ClassDecl cl, TextWriter/*?*/ errorWr) {
      Contract.Requires(cl != null);
      var isHandle = true;
      if (Attributes.ContainsBool(cl.Attributes, "handle", ref isHandle) && isHandle) {
        foreach (var trait in cl.ParentTraitHeads) {
          isHandle = true;
          if (Attributes.ContainsBool(trait.Attributes, "handle", ref isHandle) && isHandle) {
            // all is good
          } else {
            Error(cl.tok, "{0} '{1}' is marked as :handle, so all the traits it extends must be be marked as :handle as well: {2}", errorWr, cl.WhatKind, cl.Name, trait.Name);
          }
        }
        foreach (var member in cl.InheritedMembers.Concat(cl.Members)) {
          if (!member.IsGhost && !member.IsStatic) {
            Error(member.tok, "{0} '{1}' is marked as :handle, so all its non-static members must be ghost: {2}", errorWr, cl.WhatKind, cl.Name, member.Name);
          }
        }
      }
    }

    /// <summary>
    /// Check whether two declarations have the same name if capitalized.
    /// </summary>
    /// <param name="canChange">The declarations to check.</param>
    /// <param name="cantChange">Additional declarations which may conflict, but which can't be given different names.  For example, these may be the inherited members of a class.</param>
    /// <remarks>
    /// If two elements of <paramref name="canChange"/> have the same
    /// capitalization, the lowercase one will get a
    /// <c>{:_capitalizationConflict}</c> attribute.  If
    /// <paramref name="cantChange"/> is given and one of its elements conflicts
    /// with one from <paramref name="canChange"/>, the element from
    /// <paramref name="canChange"/> gets the attribute whether it is lowercase
    /// or not.
    /// </remarks>
    /// <seealso cref="HasCapitalizationConflict"/>
    private void CheckForCapitalizationConflicts<T>(IEnumerable<T> canChange, IEnumerable<T> cantChange = null) where T : Declaration {
      if (cantChange == null) {
        cantChange = Enumerable.Empty<T>();
      }
      IDictionary<string, T> declsByCapName = new Dictionary<string, T>();
      ISet<string> fixedNames = new HashSet<string>(from decl in cantChange select Capitalize(decl.CompileName));

      foreach (var decl in canChange) {
        var name = decl.CompileName;
        var capName = Capitalize(name);
        if (name == capName) {
          if (fixedNames.Contains(name)) {
            // Normally we mark the lowercase one, but in this case we can't change that one
            MarkCapitalizationConflict(decl);
          } else {
            T other;
            if (declsByCapName.TryGetValue(name, out other)) {
              // Presume that the other is the lowercase one
              MarkCapitalizationConflict(other);
            } else {
              declsByCapName.Add(name, decl);
            }
          }
        } else {
          if (declsByCapName.ContainsKey(capName)) {
            MarkCapitalizationConflict(decl);
          } else {
            declsByCapName.Add(capName, decl);
          }
        }
      }
    }

    protected string Capitalize(string str) {
      if (!str.Any(c => c != '_')) {
        return PrefixForForcedCapitalization + str;
      }
      var origStr = str;
      while (str.StartsWith("_")) {
        str = str.Substring(1) + "_";
      }
      if (!char.IsLetter(str[0])) {
        return PrefixForForcedCapitalization + origStr;
      } else {
        return char.ToUpper(str[0]) + str.Substring(1);
      }
    }

    protected virtual string PrefixForForcedCapitalization { get => "Cap_"; }

    private static void MarkCapitalizationConflict(Declaration decl) {
      decl.Attributes = new Attributes(CapitalizationConflictAttribute, new List<Expression>(), decl.Attributes);
    }

    protected static bool HasCapitalizationConflict(Declaration decl) {
      return Attributes.Contains(decl.Attributes, CapitalizationConflictAttribute);
    }

    private static string CapitalizationConflictAttribute = "_capitalizationConflict";

    private void CompileFunction(Function f, IClassWriter cw, bool lookasideBody) {
      Contract.Requires(f != null);
      Contract.Requires(cw != null);
      Contract.Requires(f.Body != null || Attributes.Contains(f.Attributes, "dllimport") || (IncludeExternMembers && Attributes.Contains(f.Attributes, "extern")));

      var w = cw.CreateFunction(IdName(f), CombineAllTypeArguments(f), f.Formals, f.ResultType, (f.Result != null) ? f.Result.Usage : Usage.Ordinary, f.tok, f.IsStatic, !f.IsExtern(out _, out _), f, false, lookasideBody);
      if (w != null) {
        IVariable accVar = null;
        if (f.IsTailRecursive) {
          if (f.IsAccumulatorTailRecursive) {
            accVar = new LocalVariable(f.tok, f.tok, "_accumulator", f.ResultType, (f.Result != null) ? f.Result.Usage : Usage.Ordinary) {
              type = f.ResultType
            };
            Expression unit;
            if (f.ResultType.IsNumericBased(Type.NumericPersuasion.Int) || f.ResultType.IsBigOrdinalType) {
              unit = new LiteralExpr(f.tok, f.TailRecursion == Function.TailStatus.Accumulate_Mul ? 1 : 0);
              unit.Type = f.ResultType;
            } else if (f.ResultType.IsNumericBased(Type.NumericPersuasion.Real)) {
              unit = new LiteralExpr(f.tok, f.TailRecursion == Function.TailStatus.Accumulate_Mul ? BigDec.FromInt(1) : BigDec.ZERO);
              unit.Type = f.ResultType;
            } else if (f.ResultType.IsBitVectorType) {
              var n = f.TailRecursion == Function.TailStatus.Accumulate_Mul ? 1 : 0;
              unit = new LiteralExpr(f.tok, n);
              unit.Type = f.ResultType;
            } else if (f.ResultType.AsSetType != null) {
              unit = new SetDisplayExpr(f.tok, !f.ResultType.IsISetType, new List<Expression>());
              unit.Type = f.ResultType;
            } else if (f.ResultType.AsMultiSetType != null) {
              unit = new MultiSetDisplayExpr(f.tok, new List<Expression>());
              unit.Type = f.ResultType;
            } else if (f.ResultType.AsSeqType != null) {
              unit = new SeqDisplayExpr(f.tok, new List<Expression>());
              unit.Type = f.ResultType;
            } else {
              Contract.Assert(false);  // unexpected type
              throw new cce.UnreachableException();
            }
            DeclareLocalVar(IdName(accVar), accVar.Type, f.tok, accVar.Usage, unit, false, w, true);
          }
          w = EmitTailCallStructure(f, w);
        }
        Coverage.Instrument(f.Body.tok, $"entry to function {f.FullName}", w);
        Contract.Assert(enclosingFunction == null);
        enclosingFunction = f;
        CompileReturnBody(f.Body, f.Original.ResultType, w, accVar, f.ResultUsage.IsSharedKind);
        Contract.Assert(enclosingFunction == f);
        enclosingFunction = null;
      }
    }

    private void CompileMethod(Program program, Method m, IClassWriter cw, bool lookasideBody) {
      Contract.Requires(cw != null);
      Contract.Requires(m != null);
      Contract.Requires(m.Body != null || Attributes.Contains(m.Attributes, "dllimport") || (IncludeExternMembers && Attributes.Contains(m.Attributes, "extern")));

      var w = cw.CreateMethod(m, CombineAllTypeArguments(m), !m.IsExtern(out _, out _), false, lookasideBody);
      if (w != null) {
        if (m.IsTailRecursive) {
          w = EmitTailCallStructure(m, w);
        }
        Coverage.Instrument(m.Body.Tok, $"entry to method {m.FullName}", w);

        var nonGhostOutsCount = m.Outs.Count(p => !p.IsReallyGhost);

        var useReturnStyleOuts = UseReturnStyleOuts(m, nonGhostOutsCount);
        foreach (var p in m.Outs) {
          if (!p.IsReallyGhost) {
            DeclareLocalOutVar(IdName(p), p.Type, p.tok, p.Usage, PlaceboValue(p.Type, w, p.tok, p.Usage, true), useReturnStyleOuts, w);
          }
        }

        w = EmitMethodReturns(m, w);

        if (m.Body == null) {
          Error(m.tok, "Method {0} has no body", w, m.FullName);
        } else {
          Contract.Assert(enclosingMethod == null);
          enclosingMethod = m;
          TrStmtList(m.Body.Body, w);
          Contract.Assert(enclosingMethod == m);
          enclosingMethod = null;
        }
      }

      if (m == program.MainMethod && IssueCreateStaticMain(m)) {
        w = CreateStaticMain(cw);
        var ty = UserDefinedType.FromTopLevelDeclWithAllBooleanTypeParameters(m.EnclosingClass);
        LocalVariable receiver = null;
        if (!m.IsStatic) {
          receiver = new LocalVariable(m.tok, m.tok, "b", ty, Usage.Ordinary) {
            type = ty
          };
          if (m.EnclosingClass is ClassDecl) {
            var wRhs = DeclareLocalVar(IdName(receiver), ty, m.tok, Usage.Ordinary, w, false);
            EmitNew(ty, m.tok, null, wRhs);
          } else {
            TrLocalVar(receiver, true, w);
          }
        }
        var typeArgs = CombineAllTypeArguments(m, ty.TypeArgs, m.TypeArgs.ConvertAll(tp => (Type)Type.Bool));
        bool customReceiver = !(m.EnclosingClass is TraitDecl) && NeedsCustomReceiver(m);

        if (receiver != null && !customReceiver) {
          w.Write("{0}.", IdName(receiver));
        } else {
          var companion = TypeName_Companion(UserDefinedType.FromTopLevelDeclWithAllBooleanTypeParameters(m.EnclosingClass), w, m.tok, m);
          w.Write("{0}.", companion);
        }
        EmitNameAndActualTypeArgs(IdName(m), TypeArgumentInstantiation.ToActuals(ForTypeParameters(typeArgs, m, false)), m.tok, w);
        w.Write("(");
        var sep = "";
        if (receiver != null && customReceiver) {
          w.Write("{0}", IdName(receiver));
          sep = ", ";
        }
        EmitTypeDescriptorsActuals(ForTypeDescriptors(typeArgs, m, false), m.tok, w, ref sep);
        w.Write(")");
        EndStmt(w);
      }
    }

    protected virtual bool IssueCreateStaticMain(Method m) {
      return !m.IsStatic || m.EnclosingClass.TypeArgs.Count != 0;
    }


    void TrCasePatternOpt<VT>(CasePattern<VT> pat, Expression rhs, TargetWriter wr, bool inLetExprBody, bool bindRefs) where VT: IVariable {
      TrCasePatternOpt(pat, rhs, null, rhs.Type, rhs.tok, wr, inLetExprBody, bindRefs);
    }

    void TrCasePatternOpt<VT>(CasePattern<VT> pat, Expression rhs, string rhs_string, Type rhsType, Bpl.IToken rhsTok, TargetWriter wr, bool inLetExprBody, bool bindRefs) where VT: IVariable {
      Contract.Requires(pat != null);
      Contract.Requires(pat.Var != null || rhs != null || rhs_string != null);
      Contract.Requires(rhs != null || rhs_string != null);
      Contract.Requires(rhsType != null && rhsTok != null);

      if (pat.Var != null) {
        // The trivial Dafny "pattern" expression
        //    var x := G
        // is translated into C# as:
        // var x := G;
        var bv = pat.Var;
        if (!bv.IsReallyGhost) {
          var w = DeclareLocalVar(IdProtect(bv.CompileName), bv.Type, rhsTok, bv.Usage, wr, !bindRefs);
          if (!bindRefs && bv.Usage.IsSharedKind) w.Write("&( ");
          if (rhs != null) {
            w = EmitCoercionIfNecessary(from: rhs.Type, to: bv.Type, tok:rhsTok, wr:w);
            TrExpr(rhs, w, inLetExprBody);
          } else {
            w.Write(rhs_string);
          }
          if (!bindRefs && bv.Usage.IsSharedKind) w.Write(" )");
        }
      } else if (pat.Arguments != null) {
        // The Dafny "pattern" expression
        //    var Pattern(x,y) := G
        // is translated into C# as:
        // var tmp := G;
        // var x := dtorX(tmp);
        // var y := dtorY(tmp);
        var ctor = pat.Ctor;
        Contract.Assert(ctor != null);  // follows from successful resolution
        Contract.Assert(pat.Arguments.Count == ctor.Formals.Count);  // follows from successful resolution
        Usage usage = Usage.Ordinary;
        if (pat.Ctor.EnclosingDatatype is IndDatatypeDecl idecl) {
          usage = idecl.Usage;
        }

        // Create the temporary variable to hold G
        var tmp_name = idGenerator.FreshId("_let_tmp_rhs");
        if (rhs != null) {
          DeclareLocalVar(tmp_name, rhs.Type, rhs.tok, usage, rhs, inLetExprBody, wr, false);
        } else {
          DeclareLocalVar(tmp_name, rhsType, rhsTok, usage, false, rhs_string, wr, false);
        }

        var dtv = (DatatypeValue)pat.Expr;
        var substMap = Resolver.TypeSubstitutionMap(ctor.EnclosingDatatype.TypeArgs, dtv.InferredTypeArgs);
        var k = 0;  // number of non-ghost formals processed
        for (int i = 0; i < pat.Arguments.Count; i++) {
          var arg = pat.Arguments[i];
          var formal = ctor.Formals[i];
          if (formal.IsReallyGhost) {
            // nothing to compile, but do a sanity check
            Contract.Assert(Contract.ForAll(arg.Vars, bv => bv.IsReallyGhost));
          } else {
            var sw = new TargetWriter(wr.IndentLevel, true);
            EmitDestructor(tmp_name, formal, k, ctor, dtv.InferredTypeArgs, arg.Expr.Type, sw);
            Type targetType = Resolver.SubstType(formal.Type, substMap);
            TrCasePatternOpt(arg, null, sw.ToString(), targetType, pat.Expr.tok, wr, inLetExprBody, bindRefs);
            k++;
          }
        }
      }
    }

    void TrExprOpt(Expression expr, Type resultType, TargetWriter wr, IVariable/*?*/ accumulatorVar, bool pointer) {
      Contract.Requires(expr != null);
      Contract.Requires(wr != null);
      Contract.Requires(resultType != null);
      Contract.Requires(accumulatorVar == null || (enclosingFunction != null && enclosingFunction.IsAccumulatorTailRecursive));

      expr = expr.Resolved;
      if (expr is LetExpr) {
        var e = (LetExpr)expr;
        if (e.Exact) {
          for (int i = 0; i < e.LHSs.Count; i++) {
            var lhs = e.LHSs[i];
            if (Contract.Exists(lhs.Vars, bv => !bv.IsReallyGhost)) {
              TrCasePatternOpt(lhs, e.RHSs[i], wr, false, true);
            }
          }
          TrExprOpt(e.Body, resultType, wr, accumulatorVar, pointer);
        } else {
          // We haven't optimized the other cases, so fallback to normal compilation
          EmitReturnExpr(e, resultType, false, wr, pointer);
        }

      } else if (expr is ITEExpr) {
        var e = (ITEExpr)expr;
        TargetWriter guardWriter;
        var thn = EmitIf(out guardWriter, true, wr);
        TrExpr(e.Test, guardWriter, false);
        Coverage.Instrument(e.Thn.tok, "then branch", thn);
        TrExprOpt(e.Thn, resultType, thn, accumulatorVar, pointer);
        TargetWriter els = wr;
        if (!(e.Els is ITEExpr)) {
          els = wr.NewBlock("", null, BlockTargetWriter.BraceStyle.Nothing);
          Coverage.Instrument(e.Thn.tok, "else branch", els);
        }
        TrExprOpt(e.Els, resultType, els, accumulatorVar, pointer);

      } else if (expr is MatchExpr) {
        var e = (MatchExpr)expr;
        //   var _source = E;
        //   if (source.is_Ctor0) {
        //     FormalType f0 = ((Dt_Ctor0)source._D).a0;
        //     ...
        //     return Body0;
        //   } else if (...) {
        //     ...
        //   } else if (true) {
        //     ...
        //   }
        string source = idGenerator.FreshId("_source");
        DeclareLocalVar(source, e.Source.Type, e.Source.tok, e.Usage, e.Source, false, wr, false);

        if (e.Cases.Count == 0) {
          // the verifier would have proved we never get here; still, we need some code that will compile
          EmitAbsurd(null, wr);
        } else {
          int i = 0;
          var sourceType = (UserDefinedType)e.Source.Type.NormalizeExpand();
          foreach (MatchCaseExpr mc in e.Cases) {
            var w = MatchCasePrelude(source, sourceType, mc.Ctor, mc.Arguments, i, e.Cases.Count, wr);
            TrExprOpt(mc.Body, resultType, w, accumulatorVar, pointer);
            i++;
          }
        }

      } else if (expr is StmtExpr) {
        var e = (StmtExpr)expr;
        TrExprOpt(e.E, resultType, wr, accumulatorVar, pointer);

      } else if (expr is FunctionCallExpr fce && fce.Function == enclosingFunction && enclosingFunction.IsTailRecursive) {
        var e = fce;
        // compile call as tail-recursive

        // assign the actual in-parameters to temporary variables
        var inTmps = new List<string>();
        var inTypes = new List<Type/*?*/>();
        if (!e.Function.IsStatic) {
          string inTmp = idGenerator.FreshId("_in");
          inTmps.Add(inTmp);
          inTypes.Add(null);
          DeclareLocalVar(inTmp, null, null, Usage.Ordinary, e.Receiver, false, wr, false);
        }
        for (int i = 0; i < e.Function.Formals.Count; i++) {
          Formal p = e.Function.Formals[i];
          if (!p.IsReallyGhost) {
            string inTmp = idGenerator.FreshId("_in");
            inTmps.Add(inTmp);
            inTypes.Add(e.Args[i].Type);
            DeclareLocalVar(inTmp, e.Args[i].Type, p.tok, p.Usage, e.Args[i], false, wr, false);
          }
        }
        // Now, assign to the formals
        int n = 0;
        if (!e.Function.IsStatic) {
          wr.Write("_this = ");
          TargetWriter wRHS;
          if (thisContext == null) {
            wRHS = wr;
          } else {
            var instantiatedType = Resolver.SubstType(e.Receiver.Type, thisContext.ParentFormalTypeParametersToActuals);
            wRHS = EmitCoercionIfNecessary(instantiatedType, UserDefinedType.FromTopLevelDecl(e.tok, thisContext), e.tok, wr);
          }
          wRHS.Write(inTmps[n]);
          EndStmt(wr);
          n++;
        }
        foreach (var p in e.Function.Formals) {
          if (!p.IsReallyGhost) {
            EmitAssignment(IdName(p), p.Type, inTmps[n], inTypes[n], wr);
            n++;
          }
        }
        Contract.Assert(n == inTmps.Count);
        // finally, the jump back to the head of the function
        EmitJumpToTailCallStart(wr);

      } else if (expr is BinaryExpr bin && bin.AccumulatesForTailRecursion != BinaryExpr.AccumulationOperand.None) {
        Contract.Assert(accumulatorVar != null);
        Contract.Assert(enclosingFunction != null);
        Contract.Assert(enclosingFunction.IsAccumulatorTailRecursive);
        Expression tailTerm;
        Expression rhs;
        var acc = new IdentifierExpr(expr.tok, accumulatorVar);
        if (bin.AccumulatesForTailRecursion == BinaryExpr.AccumulationOperand.Left) {
          rhs = new BinaryExpr(bin.tok, bin.ResolvedOp, acc, bin.E0);
          tailTerm = bin.E1;
        } else {
          switch (bin.ResolvedOp) {
            case BinaryExpr.ResolvedOpcode.Sub:
              rhs = new BinaryExpr(bin.tok, BinaryExpr.ResolvedOpcode.Add, bin.E1, acc);
              break;
            case BinaryExpr.ResolvedOpcode.SetDifference:
              rhs = new BinaryExpr(bin.tok, BinaryExpr.ResolvedOpcode.Union, bin.E1, acc);
              break;
            case BinaryExpr.ResolvedOpcode.MultiSetDifference:
              rhs = new BinaryExpr(bin.tok, BinaryExpr.ResolvedOpcode.MultiSetUnion, bin.E1, acc);
              break;
            default:
              rhs = new BinaryExpr(bin.tok, bin.ResolvedOp, bin.E1, acc);
              break;
          }
          tailTerm = bin.E0;
        }
        TargetWriter wLhs, wRhs;
        EmitAssignment(out wLhs, enclosingFunction.ResultType, out wRhs, enclosingFunction.ResultType, wr);
        TrExpr(acc, wLhs, false);
        TrExpr(rhs, wRhs, false);
        TrExprOpt(tailTerm, resultType, wr, accumulatorVar, pointer);

      } else {
        // We haven't optimized any other cases, so fallback to normal compilation
        if (enclosingFunction != null && enclosingFunction.IsAccumulatorTailRecursive) {
          // Remember to include the accumulator
          Contract.Assert(accumulatorVar != null);
          var acc = new IdentifierExpr(expr.tok, accumulatorVar);
          switch (enclosingFunction.TailRecursion) {
            case Function.TailStatus.Accumulate_Add:
              expr = new BinaryExpr(expr.tok, BinaryExpr.ResolvedOpcode.Add, expr, acc);
              break;
            case Function.TailStatus.AccumulateRight_Sub:
              expr = new BinaryExpr(expr.tok, BinaryExpr.ResolvedOpcode.Sub, expr, acc);
              break;
            case Function.TailStatus.Accumulate_Mul:
              expr = new BinaryExpr(expr.tok, BinaryExpr.ResolvedOpcode.Mul, expr, acc);
              break;
            case Function.TailStatus.Accumulate_SetUnion:
              expr = new BinaryExpr(expr.tok, BinaryExpr.ResolvedOpcode.Union, expr, acc);
              break;
            case Function.TailStatus.AccumulateRight_SetDifference:
              expr = new BinaryExpr(expr.tok, BinaryExpr.ResolvedOpcode.SetDifference, expr, acc);
              break;
            case Function.TailStatus.Accumulate_MultiSetUnion:
              expr = new BinaryExpr(expr.tok, BinaryExpr.ResolvedOpcode.MultiSetUnion, expr, acc);
              break;
            case Function.TailStatus.AccumulateRight_MultiSetDifference:
              expr = new BinaryExpr(expr.tok, BinaryExpr.ResolvedOpcode.MultiSetDifference, expr, acc);
              break;
            case Function.TailStatus.AccumulateLeft_Concat:
              expr = new BinaryExpr(expr.tok, BinaryExpr.ResolvedOpcode.Concat, acc, expr); // note order of operands
              break;
            case Function.TailStatus.AccumulateRight_Concat:
              expr = new BinaryExpr(expr.tok, BinaryExpr.ResolvedOpcode.Concat, expr, acc);
              break;
            default:
              Contract.Assert(false); // unexpected TailStatus
              throw new cce.UnreachableException();
          }
        } else {
          Contract.Assert(accumulatorVar == null);
        }
        EmitReturnExpr(expr, resultType, false, wr, pointer);
      }
    }

    void CompileReturnBody(Expression body, Type originalResultType, TargetWriter wr, IVariable/*?*/ accumulatorVar, bool pointer) {
      Contract.Requires(body != null);
      Contract.Requires(originalResultType != null);
      Contract.Requires(wr != null);
      Contract.Requires(accumulatorVar == null || (enclosingFunction != null && enclosingFunction.IsAccumulatorTailRecursive));
      TrExprOpt(body.Resolved, originalResultType, wr, accumulatorVar, pointer);
    }

    // ----- Type ---------------------------------------------------------------------------------

    protected NativeType AsNativeType(Type typ) {
      Contract.Requires(typ != null);
      if (typ.AsNewtype != null) {
        return typ.AsNewtype.NativeType;
      } else if (typ.IsBitVectorType) {
        return typ.AsBitVectorType.NativeType;
      }
      return null;
    }

    /// <summary>
    /// Note, C# reverses the order of brackets in array type names.
    /// </summary>
    protected void TypeName_SplitArrayName(Type type, TextWriter wr, Bpl.IToken tok, out string typeNameSansBrackets, out string brackets) {
      Contract.Requires(type != null);

      var xType = type.NormalizeExpand();
      if (xType.IsArrayType) {
        ArrayClassDecl at = xType.AsArrayType;
        Contract.Assert(at != null);  // follows from type.IsArrayType
        Type elType = UserDefinedType.ArrayElementType(xType);
        TypeName_SplitArrayName(elType, wr, tok, out typeNameSansBrackets, out brackets);
        brackets = TypeNameArrayBrackets(at.Dims) + brackets;
      } else {
        typeNameSansBrackets = TypeName(type, wr, tok);
        brackets = "";
      }
    }

    protected virtual string TypeNameArrayBrackets(int dims) {
      Contract.Requires(0 <= dims);
      var name = "[";
      for (int i = 1; i < dims; i++) {
        name += ",";
      }
      return name + "]";
    }

    protected bool ComplicatedTypeParameterForCompilation(TypeParameter.TPVariance v, Type t) {
      Contract.Requires(t != null);
      return v != TypeParameter.TPVariance.Non && t.IsTraitType;
    }

    protected string/*!*/ TypeNames(List<Type/*!*/>/*!*/ types, TextWriter wr, Bpl.IToken tok) {
      Contract.Requires(cce.NonNullElements(types));
      Contract.Ensures(Contract.Result<string>() != null);
      return Util.Comma(types, ty => TypeName(ty, wr, tok));
    }

    protected string PlaceboValue(Type type, TextWriter wr, Bpl.IToken tok, Usage usage, bool constructTypeParameterDefaultsFromTypeDescriptors = false) {
      Contract.Requires(type != null);
      Contract.Requires(wr != null);
      Contract.Requires(tok != null);
      Contract.Ensures(Contract.Result<string>() != null);

      type = type.NormalizeExpandKeepConstraints();
      Contract.Assert(type is NonProxyType);  // this should never happen, since all types should have been successfully resolved
      bool usePlaceboValue = !type.HasCompilableValue;
      return TypeInitializationValue(type, wr, tok, usage, usePlaceboValue, constructTypeParameterDefaultsFromTypeDescriptors);
    }

    protected string DefaultValue(Type type, TextWriter wr, Bpl.IToken tok, Usage usage, bool constructTypeParameterDefaultsFromTypeDescriptors = false) {
      Contract.Requires(type != null);
      Contract.Requires(type.HasCompilableValue);
      Contract.Requires(wr != null);
      Contract.Requires(tok != null);
      Contract.Ensures(Contract.Result<string>() != null);

      type = type.NormalizeExpandKeepConstraints();
      Contract.Assert(type is NonProxyType);  // this should never happen, since all types should have been successfully resolved
      return TypeInitializationValue(type, wr, tok, usage, false, constructTypeParameterDefaultsFromTypeDescriptors);
    }

    // ----- Stmt ---------------------------------------------------------------------------------

    public class CheckHasNoAssumes_Visitor : BottomUpVisitor
    {
      readonly Compiler compiler;
      TextWriter wr;
      public CheckHasNoAssumes_Visitor(Compiler c, TextWriter wr) {
        Contract.Requires(c != null);
        compiler = c;
        this.wr = wr;
      }
      protected override void VisitOneStmt(Statement stmt) {
        if (stmt is AssumeStmt) {
          compiler.Error(stmt.Tok, "an assume statement cannot be compiled", wr);
        } else if (stmt is AssignSuchThatStmt) {
          var s = (AssignSuchThatStmt)stmt;
          if (s.AssumeToken != null) {
            compiler.Error(stmt.Tok, "an assume statement cannot be compiled", wr);
          }
        } else if (stmt is ForallStmt) {
          var s = (ForallStmt)stmt;
          if (s.Body == null) {
            compiler.Error(stmt.Tok, "a forall statement without a body cannot be compiled", wr);
          }
        } else if (stmt is WhileStmt) {
          var s = (WhileStmt)stmt;
          if (s.Body == null) {
            // this checks ghost body-less while statements
            compiler.Error(stmt.Tok, "a while statement without a body cannot be compiled", wr);
          }
        }
      }
    }

    void TrStmtNonempty(Statement stmt, TargetWriter wr) {
      Contract.Requires(stmt != null);
      Contract.Requires(wr != null);
      TrStmt(stmt, wr);
      if (stmt.IsGhost) {
        wr.WriteLine("{ }");
      }
    }

    bool is_shared_assignment(AssignStmt stmt)
    {
      if (stmt.Lhs is IdentifierExpr ie)
      {
        return ie.Var.IsSharedKind;
      }
      else
      {
        return false;
      }
    }

    void TrStmt(Statement stmt, TargetWriter wr) {
      Contract.Requires(stmt != null);
      Contract.Requires(wr != null);

      if (stmt.IsGhost || Linear.AtomicRewriter.IsGlinearStmt(stmt)) {
        return;
      }
      if (stmt is PrintStmt) {
        var s = (PrintStmt)stmt;
        foreach (var arg in s.Args) {
          EmitPrintStmt(wr, arg);
        }
      } else if (stmt is BreakStmt) {
        var s = (BreakStmt)stmt;
        EmitBreak(s.TargetStmt.Labels.Data.AssignUniqueId(idGenerator), wr);
      } else if (stmt is ProduceStmt) {
        var s = (ProduceStmt)stmt;
        if (s.hiddenUpdate != null) {
          TrStmt(s.hiddenUpdate, wr);
        }
        if (s is YieldStmt) {
          EmitYield(wr);
        } else {
          EmitReturn(this.enclosingMethod.Outs, wr);
        }
      } else if (stmt is UpdateStmt) {
        var s = (UpdateStmt)stmt;
        var resolved = s.ResolvedStatements;
        if (resolved.Count == 1) {
          TrStmt(resolved[0], wr);
        } else {
          // multi-assignment
          Contract.Assert(s.Lhss.Count == resolved.Count);
          Contract.Assert(s.Rhss.Count == resolved.Count);
          var lhsTypes = new List<Type>();
          var rhsTypes = new List<Type>();
          var lhss = new List<Expression>();
          var rhss = new List<AssignmentRhs>();
          for (int i = 0; i < resolved.Count; i++) {
            if (!resolved[i].IsGhost && !Linear.AtomicRewriter.IsGlinearStmt(resolved[i])) {
              var lhs = s.Lhss[i];
              var rhs = s.Rhss[i];
              if (rhs is HavocRhs) {
                if (DafnyOptions.O.ForbidNondeterminism) {
                  Error(rhs.Tok, "nondeterministic assignment forbidden by /definiteAssignment:3 option", wr);
                }
              } else {
                lhss.Add(lhs);
                lhsTypes.Add(lhs.Type);
                rhss.Add(rhs);
                rhsTypes.Add(TypeOfRhs(rhs));
              }
            }
          }

          var wStmts = wr.ForkSection();
          var lvalues = new List<ILvalue>();
          foreach (Expression lhs in lhss) {
            lvalues.Add(CreateLvalue(lhs, wStmts));
          }
          List<TargetWriter> wRhss;
          EmitMultiAssignment(lhss, lvalues, lhsTypes, out wRhss, rhsTypes, wr);
          for (int i = 0; i < wRhss.Count; i++) {
            TrRhs(rhss[i], wRhss[i], wStmts);
          }
        }
      } else if (stmt is AssignStmt) {
        var s = (AssignStmt)stmt;
        Contract.Assert(!(s.Lhs is SeqSelectExpr) || ((SeqSelectExpr)s.Lhs).SelectOne);  // multi-element array assignments are not allowed
        if (s.Rhs is HavocRhs) {
          if (DafnyOptions.O.ForbidNondeterminism) {
            Error(s.Rhs.Tok, "nondeterministic assignment forbidden by /definiteAssignment:3 option", wr);
          }
        } else
        {
          bool is_shared = is_shared_assignment(s);
          var lvalue = CreateLvalue(s.Lhs, wr);
          var wStmts = wr.ForkSection();
          var wRhs = EmitAssignment(lvalue, TypeOfLhs(s.Lhs), TypeOfRhs(s.Rhs), wr);
          if (is_shared) wRhs.Write("&( "); // XXX(travis) this is obviously C++-specific
          TrRhs(s.Rhs, wRhs, wStmts);
          if (is_shared) wRhs.Write(")");
        }

      } else if (stmt is AssignSuchThatStmt) {
        var s = (AssignSuchThatStmt)stmt;
        if (DafnyOptions.O.ForbidNondeterminism) {
          Error(s.Tok, "assign-such-that statement forbidden by /definiteAssignment:3 option", wr);
        }
        if (s.AssumeToken != null) {
          // Note, a non-ghost AssignSuchThatStmt may contain an assume
          Error(s.AssumeToken, "an assume statement cannot be compiled", wr);
        } else {
          var lhss = s.Lhss.ConvertAll(lhs => ((IdentifierExpr)lhs.Resolved).Var);  // the resolver allows only IdentifierExpr left-hand sides
          var missingBounds = ComprehensionExpr.BoundedPool.MissingBounds(lhss, s.Bounds, ComprehensionExpr.BoundedPool.PoolVirtues.Enumerable);
          if (missingBounds.Count != 0) {
            foreach (var bv in missingBounds) {
              Error(s.Tok, "this assign-such-that statement is too advanced for the current compiler; Dafny's heuristics cannot find any bound for variable '{0}'", wr, bv.Name);
            }
          } else {
            Contract.Assert(s.Bounds != null);
            TrAssignSuchThat(lhss, s.Expr, s.Bounds, s.Tok.line, wr, false);
          }
        }

      } else if (stmt is AssignOrReturnStmt) {
        var s = (AssignOrReturnStmt)stmt;
        // TODO there's potential here to use target-language specific features such as exceptions
        // to make it more target-language idiomatic and improve performance
        TrStmtList(s.ResolvedStatements, wr);

      } else if (stmt is ExpectStmt) {
        var s = (ExpectStmt)stmt;
        // TODO there's potential here to use target-language specific features such as exceptions
        // to make it more target-language idiomatic and improve performance
        TargetWriter guardWriter;
        TargetWriter bodyWriter = EmitIf(out guardWriter, false, wr);
        var negated = new UnaryOpExpr(s.Tok, UnaryOpExpr.Opcode.Not, s.Expr);
        negated.Type = Type.Bool;
        TrExpr(negated, guardWriter, false);
        EmitHalt(s.Tok, s.Message, bodyWriter);

      } else if (stmt is CallStmt) {
        var s = (CallStmt)stmt;
        TrCallStmt(s, null, wr);

      } else if (stmt is BlockStmt) {
        var w = wr.NewBlock("", null, BlockTargetWriter.BraceStyle.Nothing, BlockTargetWriter.BraceStyle.Newline);
        TrStmtList(((BlockStmt)stmt).Body, w);

      } else if (stmt is IfStmt) {
        IfStmt s = (IfStmt)stmt;
        if (s.Guard == null) {
          if (DafnyOptions.O.ForbidNondeterminism) {
            Error(s.Tok, "nondeterministic if statement forbidden by /definiteAssignment:3 option", wr);
          }
          // we can compile the branch of our choice
          if (s.Els == null) {
            // let's compile the "else" branch, since that involves no work
            // (still, let's leave a marker in the source code to indicate that this is what we did)
            Coverage.UnusedInstrumentationPoint(s.Thn.Tok, "then branch");
            wr = wr.NewBlock("if (!false) ");
            Coverage.Instrument(s.Tok, "implicit else branch", wr);
            wr.WriteLine("if (!false) { }");
          } else {
            // let's compile the "then" branch
            wr = wr.NewBlock("if (true) ");
            Coverage.Instrument(s.Thn.Tok, "then branch", wr);
            TrStmtList(s.Thn.Body, wr);
            Coverage.UnusedInstrumentationPoint(s.Els.Tok, "else branch");
          }
        } else {
          if (s.IsBindingGuard && DafnyOptions.O.ForbidNondeterminism) {
            Error(s.Tok, "binding if statement forbidden by /definiteAssignment:3 option", wr);
          }
          TargetWriter guardWriter;
          var coverageForElse = Coverage.IsRecording && !(s.Els is IfStmt);
          var thenWriter = EmitIf(out guardWriter, s.Els != null || coverageForElse, wr);
          TrExpr(s.IsBindingGuard ? Translator.AlphaRename((ExistsExpr)s.Guard, "eg_d") : s.Guard, guardWriter, false);

          // We'd like to do "TrStmt(s.Thn, indent)", except we want the scope of any existential variables to come inside the block
          if (s.IsBindingGuard) {
            IntroduceAndAssignBoundVars((ExistsExpr)s.Guard, thenWriter);
          }
          Coverage.Instrument(s.Thn.Tok, "then branch", thenWriter);
          TrStmtList(s.Thn.Body, thenWriter);

          if (coverageForElse) {
            wr = wr.NewBlock("", null, BlockTargetWriter.BraceStyle.Nothing);
            if (s.Els == null) {
              Coverage.Instrument(s.Tok, "implicit else branch", wr);
            } else {
              Coverage.Instrument(s.Els.Tok, "else branch", wr);
            }
          }
          if (s.Els != null) {
            TrStmtNonempty(s.Els, wr);
          }
        }

      } else if (stmt is AlternativeStmt) {
        var s = (AlternativeStmt)stmt;
        if (DafnyOptions.O.ForbidNondeterminism && 2 <= s.Alternatives.Count) {
          Error(s.Tok, "case-based if statement forbidden by /definiteAssignment:3 option", wr);
        }
        foreach (var alternative in s.Alternatives) {
          TargetWriter guardWriter;
          var thn = EmitIf(out guardWriter, true, wr);
          TrExpr(alternative.IsBindingGuard ? Translator.AlphaRename((ExistsExpr)alternative.Guard, "eg_d") : alternative.Guard, guardWriter, false);
          if (alternative.IsBindingGuard) {
            IntroduceAndAssignBoundVars((ExistsExpr)alternative.Guard, thn);
          }
          Coverage.Instrument(alternative.Tok, "if-case branch", thn);
          TrStmtList(alternative.Body, thn);
        }
        using (var wElse = wr.NewBlock("", null, BlockTargetWriter.BraceStyle.Nothing)) {
          EmitAbsurd("unreachable alternative", wElse);
        }

      } else if (stmt is WhileStmt) {
        WhileStmt s = (WhileStmt)stmt;
        if (s.Body == null) {
          return;
        }
        if (s.Guard == null) {
          if (DafnyOptions.O.ForbidNondeterminism) {
            Error(s.Tok, "nondeterministic loop forbidden by /definiteAssignment:3 option", wr);
          }
          // This loop is allowed to stop iterating at any time. We choose to never iterate, but we still
          // emit a loop structure. The structure "while (false) { }" comes to mind, but that results in
          // an "unreachable code" error from Java, so we instead use "while (true) { break; }".
          TargetWriter guardWriter;
          var wBody = CreateWhileLoop(out guardWriter, wr);
          guardWriter.Write("true");
          EmitBreak(s.Labels?.Data.AssignUniqueId(idGenerator), wBody);
          Coverage.UnusedInstrumentationPoint(s.Body.Tok, "while body");
        } else {
          var guardWriter = EmitWhile(s.Body.Tok, s.Body.Body, wr);
          TrExpr(s.Guard, guardWriter, false);
        }

      } else if (stmt is AlternativeLoopStmt) {
        var s = (AlternativeLoopStmt)stmt;
        if (DafnyOptions.O.ForbidNondeterminism) {
          Error(s.Tok, "case-based loop forbidden by /definiteAssignment:3 option", wr);
        }
        if (s.Alternatives.Count != 0) {
          TargetWriter whileGuardWriter;
          var w = CreateWhileLoop(out whileGuardWriter, wr);
          whileGuardWriter.Write("true");
          foreach (var alternative in s.Alternatives) {
            TargetWriter guardWriter;
            var thn = EmitIf(out guardWriter, true, w);
            TrExpr(alternative.Guard, guardWriter, false);
            Coverage.Instrument(alternative.Tok, "while-case branch", thn);
            TrStmtList(alternative.Body, thn);
          }
          using (var wElse = w.NewBlock("")) {
            EmitBreak(null, wElse);
          }
        }

      } else if (stmt is ForallStmt) {
        var s = (ForallStmt)stmt;
        if (s.Kind != ForallStmt.BodyKind.Assign) {
          // Call and Proof have no side effects, so they can simply be optimized away.
          return;
        } else if (s.BoundVars.Count == 0) {
          // the bound variables just spell out a single point, so the forall statement is equivalent to one execution of the body
          TrStmt(s.Body, wr);
          return;
        }
        var s0 = (AssignStmt)s.S0;
        if (s0.Rhs is HavocRhs) {
          if (DafnyOptions.O.ForbidNondeterminism) {
            Error(s0.Rhs.Tok, "nondeterministic assignment forbidden by /definiteAssignment:3 option", wr);
          }
          // The forall statement says to havoc a bunch of things.  This can be efficiently compiled
          // into doing nothing.
          return;
        }
        var rhs = ((ExprRhs)s0.Rhs).Expr;

        if (CanSequentializeForall(s.BoundVars, s.Bounds, s.Range, s0.Lhs, rhs)) {
          // Just put the statement inside the loops
          var wLoop = CompileGuardedLoops(s.BoundVars, s.Bounds, s.Range, wr);
          TrStmt(s0, wLoop);
        } else {
          // Compile:
          //   forall (w,x,y,z | Range(w,x,y,z)) {
          //     LHS(w,x,y,z) := RHS(w,x,y,z);
          //   }
          // where w,x,y,z have types seq<W>,set<X>,int,bool and LHS has L-1 top-level subexpressions
          // (that is, L denotes the number of top-level subexpressions of LHS plus 1),
          // into:
          //   var ingredients = new List< L-Tuple >();
          //   foreach (W w in sq.UniqueElements) {
          //     foreach (X x in st.Elements) {
          //       for (BigInteger y = Lo; j < Hi; j++) {
          //         for (bool z in Helper.AllBooleans) {
          //           if (Range(w,x,y,z)) {
          //             ingredients.Add(new L-Tuple( LHS0(w,x,y,z), LHS1(w,x,y,z), ..., RHS(w,x,y,z) ));
          //           }
          //         }
          //       }
          //     }
          //   }
          //   foreach (L-Tuple l in ingredients) {
          //     LHS[ l0, l1, l2, ..., l(L-2) ] = l(L-1);
          //   }
          //
          // Note, because the .NET Tuple class only supports up to 8 components, the compiler implementation
          // here supports arrays only up to 6 dimensions.  This does not seem like a serious practical limitation.
          // However, it may be more noticeable if the forall statement supported forall assignments in its
          // body.  To support cases where tuples would need more than 8 components, .NET Tuple's would have to
          // be nested.

          // Temporary names
          var c = idGenerator.FreshNumericId("_ingredients+_tup");
          string ingredients = "_ingredients" + c;
          string tup = "_tup" + c;

          // Compute L
          int L;
          string tupleTypeArgs;
          List<Type> tupleTypeArgsList;
          if (s0.Lhs is MemberSelectExpr) {
            var lhs = (MemberSelectExpr) s0.Lhs;
            L = 2;
            tupleTypeArgs = TypeArgumentName(lhs.Obj.Type, wr, lhs.tok);
            tupleTypeArgsList = new List<Type> { lhs.Obj.Type };
          } else if (s0.Lhs is SeqSelectExpr) {
            var lhs = (SeqSelectExpr) s0.Lhs;
            L = 3;
            // note, we might as well do the BigInteger-to-int cast for array indices here, before putting things into the Tuple rather than when they are extracted from the Tuple
            tupleTypeArgs = TypeArgumentName(lhs.Seq.Type, wr, lhs.tok) + IntSelect;
            tupleTypeArgsList = new List<Type> { lhs.Seq.Type, null };
          } else {
            var lhs = (MultiSelectExpr) s0.Lhs;
            L = 2 + lhs.Indices.Count;
            if (8 < L) {
              Error(lhs.tok, "compiler currently does not support assignments to more-than-6-dimensional arrays in forall statements", wr);
              return;
            }
            tupleTypeArgs = TypeArgumentName(lhs.Array.Type, wr, lhs.tok);
            tupleTypeArgsList = new List<Type> { lhs.Array.Type };
            for (int i = 0; i < lhs.Indices.Count; i++) {
              // note, we might as well do the BigInteger-to-int cast for array indices here, before putting things into the Tuple rather than when they are extracted from the Tuple
              tupleTypeArgs += IntSelect;
              tupleTypeArgsList.Add(null);
            }

          }
          tupleTypeArgs += "," + TypeArgumentName(rhs.Type, wr, rhs.tok);
          tupleTypeArgsList.Add(rhs.Type);

          // declare and construct "ingredients"
          var wrOuter = EmitIngredients(wr, ingredients, L, tupleTypeArgs, s, s0, rhs);

          //   foreach (L-Tuple l in ingredients) {
          //     LHS[ l0, l1, l2, ..., l(L-2) ] = l(L-1);
          //   }
          TargetWriter collWriter;
          TargetTupleSize = L;
          wr = CreateForeachIngredientLoop(tup, L, tupleTypeArgs, out collWriter, wrOuter);
          collWriter.Write(ingredients);
          {
            var wTup = new TargetWriter(wr.IndentLevel, true);
            var wCoerceTup = EmitCoercionToArbitraryTuple(wTup);
            wCoerceTup.Write(tup);
            tup = wTup.ToString();
          }
          if (s0.Lhs is MemberSelectExpr) {
            EmitMemberSelect(s0, tupleTypeArgsList, wr, tup);
          } else if (s0.Lhs is SeqSelectExpr) {
            EmitSeqSelect(s0, tupleTypeArgsList, wr, tup);
          } else {
            EmitMultiSelect(s0, tupleTypeArgsList, wr, tup, L);
          }
        }
      } else if (stmt is ConcreteSyntaxStatement) {
        var s = (ConcreteSyntaxStatement) stmt;
        TrStmt(s.ResolvedStatement, wr);

      } else if (stmt is MatchStmt) {
        MatchStmt s = (MatchStmt)stmt;
        // Type source = e;
        // if (source.is_Ctor0) {
        //   FormalType f0 = ((Dt_Ctor0)source._D).a0;
        //   ...
        //   Body0;
        // } else if (...) {
        //   ...
        // } else if (true) {
        //   ...
        // }
        if (s.Cases.Count != 0) {
          string source = idGenerator.FreshId("_source");
          DeclareLocalVar(source, s.Source.Type, s.Source.tok, s.Usage, s.Source, false, wr, false);

          int i = 0;
          var sourceType = (UserDefinedType)s.Source.Type.NormalizeExpand();
          foreach (MatchCaseStmt mc in s.Cases) {
            var w = MatchCasePrelude(source, sourceType, cce.NonNull(mc.Ctor), mc.Arguments, i, s.Cases.Count, wr);
            TrStmtList(mc.Body, w);
            i++;
          }
        }

      } else if (stmt is VarDeclStmt) {
        var s = (VarDeclStmt)stmt;
        var i = 0;
        foreach (var local in s.Locals) {
          bool hasRhs = s.Update is AssignSuchThatStmt;
          if (!hasRhs && s.Update is UpdateStmt u) {
            if (i < u.Rhss.Count && u.Rhss[i] is HavocRhs) {
              // there's no specific initial value
            } else {
              hasRhs = true;
            }
          }
          TrLocalVar(local, !hasRhs, wr);
          i++;
        }
        if (s.Update != null) {
          TrStmt(s.Update, wr);
        }

      } else if (stmt is VarDeclPattern) {
        var s = (VarDeclPattern)stmt;
        if (Contract.Exists(s.LHS.Vars, bv => !bv.IsReallyGhost)) {
          TrCasePatternOpt(s.LHS, s.RHS, wr, false, false);
        }
      } else if (stmt is ModifyStmt) {
        var s = (ModifyStmt)stmt;
        if (s.Body != null) {
          TrStmt(s.Body, wr);
        } else if (DafnyOptions.O.ForbidNondeterminism) {
          Error(s.Tok, "modify statement without a body forbidden by /definiteAssignment:3 option", wr);
        }

      } else {
        Contract.Assert(false); throw new cce.UnreachableException();  // unexpected statement
      }
    }

    protected virtual TargetWriter EmitIngredients(TargetWriter wr, string ingredients, int L, string tupleTypeArgs, ForallStmt s, AssignStmt s0, Expression rhs){

      using (var wrVarInit = DeclareLocalVar(ingredients, null, null, Usage.Ordinary, wr, false)){   // REVIEW: Linear?
        EmitEmptyTupleList(tupleTypeArgs, wrVarInit);
      }

      var wrOuter = wr;
      wr = CompileGuardedLoops(s.BoundVars, s.Bounds, s.Range, wr);

      using (var wrTuple = EmitAddTupleToList(ingredients, tupleTypeArgs, wr)){
        if (s0.Lhs is MemberSelectExpr){
          var lhs = (MemberSelectExpr) s0.Lhs;
          TrExpr(lhs.Obj, wrTuple, false);
        }
        else if (s0.Lhs is SeqSelectExpr){
          var lhs = (SeqSelectExpr) s0.Lhs;
          TrExpr(lhs.Seq, wrTuple, false);
          wrTuple.Write(", ");
          EmitExprAsInt(lhs.E0, false, wrTuple);
        }
        else{
          var lhs = (MultiSelectExpr) s0.Lhs;
          TrExpr(lhs.Array, wrTuple, false);
          for (int i = 0; i < lhs.Indices.Count; i++){
            wrTuple.Write(", ");
            EmitExprAsInt(lhs.Indices[i], false, wrTuple);
          }
        }

        wrTuple.Write(", ");
        TrExpr(rhs, wrTuple, false);
      }

      return wrOuter;
    }

    protected virtual void EmitMemberSelect(AssignStmt s0, List<Type> tupleTypeArgsList, TargetWriter wr, string tup) {
      var lhs = (MemberSelectExpr)s0.Lhs;

      var typeArgs = TypeArgumentInstantiation.ListFromMember(lhs.Member, null, lhs.TypeApplication_JustMember);
      var lvalue = EmitMemberSelect(w => {
        var wObj = EmitCoercionIfNecessary(from: null, to: tupleTypeArgsList[0], s0.Tok, w);
        EmitTupleSelect(tup, 0, wObj);
      }, lhs.Obj.Type, lhs.Member, typeArgs, lhs.TypeArgumentSubstitutionsWithParents(), lhs.Type);

      var wRhs = EmitAssignment(lvalue, lhs.Type, tupleTypeArgsList[1], wr);
      var wCoerced = EmitCoercionIfNecessary(from: null, to: tupleTypeArgsList[1], tok: s0.Tok, wr: wRhs);
      EmitTupleSelect(tup, 1, wCoerced);
    }

    protected virtual void EmitSeqSelect(AssignStmt s0, List<Type> tupleTypeArgsList, TargetWriter wr, string tup){
      var lhs = (SeqSelectExpr) s0.Lhs;
      TargetWriter wColl, wIndex, wValue;
      EmitIndexCollectionUpdate(out wColl, out wIndex, out wValue, wr, nativeIndex: true);
      var wCoerce = EmitCoercionIfNecessary(from: null, to: lhs.Seq.Type, tok: s0.Tok, wr: wColl);
      EmitTupleSelect(tup, 0, wCoerce);
      var wCast = EmitCoercionToNativeInt(wIndex);
      EmitTupleSelect(tup, 1, wCast);
      EmitTupleSelect(tup, 2, wValue);
      EndStmt(wr);
    }

    protected virtual void EmitMultiSelect(AssignStmt s0, List<Type> tupleTypeArgsList, TargetWriter wr, string tup, int L){
      var lhs = (MultiSelectExpr) s0.Lhs;
      var wArray = new TargetWriter(wr.IndentLevel, true);
      var wCoerced = EmitCoercionIfNecessary(from: null, to: tupleTypeArgsList[0], tok: s0.Tok, wr: wArray);
      EmitTupleSelect(tup, 0, wCoerced);
      var array = wArray.ToString();
      var indices = new List<string>();
      for (int i = 0; i < lhs.Indices.Count; i++){
        var wIndex = new TargetWriter();
        EmitTupleSelect(tup, i + 1, wIndex);
        indices.Add(wIndex.ToString());
      }
      var lvalue = EmitArraySelectAsLvalue(array, indices, tupleTypeArgsList[L - 1]);
      var wRhs = lvalue.EmitWrite(wr);
      EmitTupleSelect(tup, L - 1, wRhs);
      EndStmt(wr);
    }

    protected TargetWriter CompileGuardedLoops(List<BoundVar> bvs, List<ComprehensionExpr.BoundedPool> bounds, Expression range, TargetWriter wr) {
      var n = bvs.Count;
      Contract.Assert(bounds.Count == n);
      for (int i = 0; i < n; i++) {
        var bound = bounds[i];
        var bv = bvs[i];
        TargetWriter collectionWriter;
        var tmpVar = idGenerator.FreshId("_guard_loop_");
        wr = CreateForeachLoop(tmpVar, GetCollectionEnumerationType(bound, bv), IdName(bv), bv.Type, true, range.tok, out collectionWriter, wr);
        CompileCollection(bound, bv, false, false, null, collectionWriter, bounds, bvs, i);
      }

      // if (range) {
      //   ingredients.Add(new L-Tuple( LHS0(w,x,y,z), LHS1(w,x,y,z), ..., RHS(w,x,y,z) ));
      // }
      TargetWriter guardWriter;
      wr = EmitIf(out guardWriter, false, wr);
      foreach (var bv in bvs) {
        var bvConstraints = Resolver.GetImpliedTypeConstraint(bv, bv.Type);
        TrParenExpr(bvConstraints, guardWriter, false);
        guardWriter.Write(" && ");
      }
      TrParenExpr(range, guardWriter, false);

      return wr;
    }

    /// <summary>
    /// For a enumerator for the bounded pool "bound" and bounded variable "bv", return the type of the elements
    /// return from the enumerator. Usually, this is just "bv.Type", since the enumerated values are going to be
    /// bound to "bv". However, the type may also be a supertype of "bv.Type", in which case a downcast will be
    /// needed somewhere. For example, for
    ///     var ts: seq(Trait) := ...;
    ///     var cs: set(Class) := set bv: Class :: bv in ts;
    /// the type of "bv" is "Class", but the values returned by the enumeration will have type "Trait".
    /// </summary>
    Type GetCollectionEnumerationType(ComprehensionExpr.BoundedPool bound, IVariable bv) {
      Contract.Requires(bound != null);
      Contract.Requires(bv != null);

      if (bound is ComprehensionExpr.CollectionBoundedPool) {
        var b = (ComprehensionExpr.CollectionBoundedPool)bound;
        return b.CollectionElementType;
      } else if (bound is ComprehensionExpr.SubSetBoundedPool) {
        var b = (ComprehensionExpr.SubSetBoundedPool)bound;
        return b.UpperBound.Type;
      } else if (bound is ComprehensionExpr.ExactBoundedPool) {
        var b = (ComprehensionExpr.ExactBoundedPool)bound;
        return b.E.Type;
      } else {
        return bv.Type;
      }
    }

    void CompileCollection(ComprehensionExpr.BoundedPool bound, IVariable bv, bool inLetExprBody, bool includeDuplicates, Translator.Substituter/*?*/ su,
        TargetWriter collectionWriter,
        List<ComprehensionExpr.BoundedPool>/*?*/ bounds = null, List<BoundVar>/*?*/ boundVars = null, int boundIndex = 0) {
      Contract.Requires(bound != null);
      Contract.Requires(bounds == null || (boundVars != null && bounds.Count == boundVars.Count && 0 <= boundIndex && boundIndex < bounds.Count));
      Contract.Requires(collectionWriter != null);
      var propertySuffix = SupportsProperties ? "" : "()";
      su = su ?? new Translator.Substituter(null, new Dictionary<IVariable, Expression>(), new Dictionary<TypeParameter, Type>());

      if (bound is ComprehensionExpr.BoolBoundedPool) {
        collectionWriter.Write("{0}.AllBooleans()", GetHelperModuleName());
      } else if (bound is ComprehensionExpr.CharBoundedPool) {
        collectionWriter.Write("{0}.AllChars()", GetHelperModuleName());
      } else if (bound is ComprehensionExpr.IntBoundedPool) {
        var b = (ComprehensionExpr.IntBoundedPool)bound;
        TargetWriter wLo, wHi;
        EmitIntegerRange(bv.Type, out wLo, out wHi, collectionWriter);
        if (b.LowerBound == null) {
          EmitNull(bv.Type, wLo);
        } else if (bounds != null) {
          var low = SubstituteBound(b, bounds, boundVars, boundIndex, true);
          TrExpr(su.Substitute(low), wLo, inLetExprBody);
        } else {
          TrExpr(su.Substitute(b.LowerBound), wLo, inLetExprBody);
        }
        if (b.UpperBound == null) {
          EmitNull(bv.Type, wHi);
        } else if (bounds != null) {
          var high = SubstituteBound(b, bounds, boundVars, boundIndex, false);
          TrExpr(su.Substitute(high), wHi, inLetExprBody);
        } else {
          TrExpr(su.Substitute(b.UpperBound), wHi, inLetExprBody);
        }
      } else if (bound is AssignSuchThatStmt.WiggleWaggleBound) {
        collectionWriter.Write("{0}.AllIntegers()", GetHelperModuleName());
      } else if (bound is ComprehensionExpr.ExactBoundedPool) {
        var b = (ComprehensionExpr.ExactBoundedPool)bound;
        EmitSingleValueGenerator(su.Substitute(b.E), inLetExprBody, TypeName(b.E.Type, collectionWriter, b.E.tok), collectionWriter);
      } else if (bound is ComprehensionExpr.SetBoundedPool) {
        var b = (ComprehensionExpr.SetBoundedPool)bound;
        TrParenExpr(su.Substitute(b.Set), collectionWriter, inLetExprBody);
        collectionWriter.Write(".Elements" + propertySuffix);
      } else if (bound is ComprehensionExpr.MultiSetBoundedPool) {
        var b = (ComprehensionExpr.MultiSetBoundedPool)bound;
        TrParenExpr(su.Substitute(b.MultiSet), collectionWriter, inLetExprBody);
        collectionWriter.Write((includeDuplicates ? ".Elements" : ".UniqueElements") + propertySuffix);
      } else if (bound is ComprehensionExpr.SubSetBoundedPool) {
        var b = (ComprehensionExpr.SubSetBoundedPool)bound;
        TrParenExpr(su.Substitute(b.UpperBound), collectionWriter, inLetExprBody);
        collectionWriter.Write(".AllSubsets" + propertySuffix);
      } else if (bound is ComprehensionExpr.MapBoundedPool) {
        var b = (ComprehensionExpr.MapBoundedPool)bound;
        TrParenExpr(su.Substitute(b.Map), collectionWriter, inLetExprBody);
        collectionWriter.Write(".Keys{0}.Elements{0}", propertySuffix);
      } else if (bound is ComprehensionExpr.SeqBoundedPool) {
        var b = (ComprehensionExpr.SeqBoundedPool)bound;
        TrParenExpr(su.Substitute(b.Seq), collectionWriter, inLetExprBody);
        collectionWriter.Write((includeDuplicates ? ".Elements" : ".UniqueElements") + propertySuffix);
      } else if (bound is ComprehensionExpr.DatatypeBoundedPool) {
        var b = (ComprehensionExpr.DatatypeBoundedPool)bound;
        collectionWriter.Write("{0}.AllSingletonConstructors{1}", TypeName_Companion(bv.Type, collectionWriter, bv.Tok, null), propertySuffix);
      } else {
        Contract.Assert(false); throw new cce.UnreachableException();  // unexpected BoundedPool type
      }
    }

    private Expression SubstituteBound(ComprehensionExpr.IntBoundedPool b, List<ComprehensionExpr.BoundedPool> bounds, List<BoundVar> boundVars, int index, bool lowBound) {
      Contract.Requires(b != null);
      Contract.Requires((lowBound ? b.LowerBound : b.UpperBound) != null);
      Contract.Requires(bounds != null);
      Contract.Requires(boundVars != null);
      Contract.Requires(bounds.Count == boundVars.Count);
      Contract.Requires(0 <= index && index < boundVars.Count);
      // if the outer bound is dependent on the inner boundvar, we need to
      // substitute the inner boundvar with its bound.
      var bnd = lowBound ? b.LowerBound : b.UpperBound;
      var sm = new Dictionary<IVariable, Expression>();
      for (int i = index+1; i < boundVars.Count; i++) {
        var bound = bounds[i];
        if (bound is ComprehensionExpr.IntBoundedPool) {
          var ib = (ComprehensionExpr.IntBoundedPool)bound;
          var bv = boundVars[i];
          sm[bv] = lowBound ? ib.LowerBound : ib.UpperBound;
        }
      }
      var su = new Translator.Substituter(null, sm, new Dictionary<TypeParameter, Type>());
      return su.Substitute(bnd);
    }

    private void IntroduceAndAssignBoundVars(ExistsExpr exists, TargetWriter wr) {
      Contract.Requires(exists != null);
      Contract.Assume(exists.Bounds != null);  // follows from successful resolution
      Contract.Assert(exists.Range == null);  // follows from invariant of class IfStmt
      foreach (var bv in exists.BoundVars) {
        TrLocalVar(bv, false, wr);
      }
      var ivars = exists.BoundVars.ConvertAll(bv => (IVariable)bv);
      TrAssignSuchThat(ivars, exists.Term, exists.Bounds, exists.tok.line, wr, false);
    }

    private bool CanSequentializeForall(List<BoundVar> bvs, List<ComprehensionExpr.BoundedPool> bounds, Expression range, Expression lhs, Expression rhs) {
      // Given a statement
      //
      //   forall i, ... | R {
      //     L := E;
      //   }
      //
      // we sequentialize if all of these conditions hold:
      //
      //   1. There are no calls to functions which may have read effects in R,
      //      L, or E
      //   2. Each index value will be produced only once (note that this is
      //      currently always true thanks to the use of UniqueElements())
      //   3. If L has the form A[I] for some A and I, then one of the following
      //      is true:
      //      a. There are no array dereferences or array-to-sequence
      //         conversions in R, A, I, or E
      //      b. All of the following are true:
      //         i.   There is only one bound variable; call it i
      //         ii.  I is the variable i
      //         iii. Each array dereference in R, A, or E has the form B[i] for
      //              some B
      //         iv.  There are no array-to-sequence conversions in R, A, or E
      //   4. If L has the form A[I, J, ...] for some A, I, J, ... then there
      //      are no multi-D array dereferences in R, A, E, or any of the
      //      indices I, J, ...
      //   5. If L has the form O.f for some field f, then one of the following
      //      is true:
      //      a. There are no accesses of f in R, O, or E
      //      b. All of the following are true:
      //         i.   There is only one bound variable; call it i
      //         ii.  O is the variable i
      //         iii. Each access of f in R or E has the form i.f
      //
      // TODO It may be possible to weaken rule 4 by adding an alternative
      // similar to rules 3b and 5b.
      Contract.Assert(bvs.Count == bounds.Count);

      if (!noImpureFunctionCalls(lhs, rhs, range)) {
        return false;
      } else if (lhs is SeqSelectExpr sse) {
        return
          no1DArrayAccesses(sse.Seq, sse.E0, range, rhs) ||

          bvs.Count == 1 &&
          isVar(bvs[0], sse.E0) &&
          indexIsAlwaysVar(bvs[0], range, sse.Seq, rhs); // also covers sequence conversions
      } else if (lhs is MultiSelectExpr mse) {
        return
          noMultiDArrayAccesses(mse.Array, range, rhs) &&
          noMultiDArrayAccesses(mse.Indices.ToArray());
      } else {
        // !@#$#@$% scope rules won't let me call this mse ...
        var mse2 = (MemberSelectExpr) lhs;

        return
          noFieldAccesses(mse2.Member, mse2.Obj, range, rhs) ||

          bvs.Count == 1 &&
          isVar(bvs[0], mse2.Obj) &&
          accessedObjectIsAlwaysVar(mse2.Member, bvs[0], range, rhs);
      }

      bool noImpureFunctionCalls(params Expression[] exprs) {
        return exprs.All(e => Check<ApplyExpr>(e, ae => {
          var ty = (UserDefinedType) ae.Function.Type.NormalizeExpandKeepConstraints();
          return ArrowType.IsPartialArrowTypeName(ty.Name) || ArrowType.IsTotalArrowTypeName(ty.Name);
        }));
      }

      bool no1DArrayAccesses(params Expression[] exprs) {
        return exprs.All(e => Check<SeqSelectExpr>(e, sse => !sse.Seq.Type.IsArrayType)); // allow sequence accesses
      }

      bool noMultiDArrayAccesses(params Expression[] exprs) {
        return exprs.All(e => Check<MultiSelectExpr>(e, _ => false));
      }

      bool noFieldAccesses(MemberDecl member, params Expression[] exprs) {
        return exprs.All(e => Check<MemberSelectExpr>(e, mse => mse.Member != member));
      }

      bool isVar(BoundVar var, Expression expr) {
        return expr.Resolved is IdentifierExpr ie && ie.Var == var;
      }

      bool indexIsAlwaysVar(BoundVar var, params Expression[] exprs) {
        return exprs.All(e => Check<SeqSelectExpr>(e, sse2 => sse2.SelectOne && isVar(var, sse2.E0)));
      }

      bool accessedObjectIsAlwaysVar(MemberDecl member, BoundVar var, params Expression[] exprs) {
        return exprs.All(e => Check<MemberSelectExpr>(e, mse => mse.Member != member || isVar(var, mse.Obj)));
      }
    }

    /// <summary>
    /// Check all of the given expression's subexpressions of a given type
    /// using a predicate.  Returns true only if the predicate returns true for
    /// all subexpressions of type <typeparamref name="E"/>.
    /// </summary>
    private static bool Check<E>(Expression e, Predicate<E> pred) where E : Expression {
      var checker = new Checker<E>(pred);
      checker.Visit(e, null);
      return checker.Passing;
    }

    private class Checker<E> : TopDownVisitor<object> where E : Expression {
      private readonly Predicate<E> Pred;
      public bool Passing = true;

      public Checker(Predicate<E> pred) {
        Pred = pred;
      }

      protected override bool VisitOneExpr(Expression expr, ref object st) {
        if (expr is E e && !Pred(e)) {
          Passing = false;
          return false;
        } else {
          return true;
        }
      }
    }

    private void TrAssignSuchThat(List<IVariable> lhss, Expression constraint, List<ComprehensionExpr.BoundedPool> bounds, int debuginfoLine, TargetWriter wr, bool inLetExprBody) {
      Contract.Requires(lhss != null);
      Contract.Requires(constraint != null);
      Contract.Requires(bounds != null);
      // For "i,j,k,l :| R(i,j,k,l);", emit something like:
      //
      // for (BigInteger iterLimit = 5; ; iterLimit *= 2) {
      //   var il$0 = iterLimit;
      //   foreach (L l' in sq.Elements) { l = l';
      //     if (il$0 == 0) { break; }  il$0--;
      //     var il$1 = iterLimit;
      //     foreach (K k' in st.Elements) { k = k';
      //       if (il$1 == 0) { break; }  il$1--;
      //       var il$2 = iterLimit;
      //       j = Lo;
      //       for (;; j++) {
      //         if (il$2 == 0) { break; }  il$2--;
      //         foreach (bool i' in Helper.AllBooleans) { i = i';
      //           if (R(i,j,k,l)) {
      //             goto ASSIGN_SUCH_THAT_<id>;
      //           }
      //         }
      //       }
      //     }
      //   }
      // }
      // throw new Exception("assign-such-that search produced no value"); // a verified program never gets here; however, we need this "throw" to please the C# compiler
      // ASSIGN_SUCH_THAT_<id>: ;
      //
      // where the iterLimit loop can be omitted if lhss.Count == 1 or if all bounds are finite.  Further optimizations could be done, but
      // are omitted for now.
      //
      var n = lhss.Count;
      Contract.Assert(bounds.Count == n);
      var c = idGenerator.FreshNumericId("_ASSIGN_SUCH_THAT_+_iterLimit_");
      var doneLabel = "_ASSIGN_SUCH_THAT_" + c;
      var iterLimit = "_iterLimit_" + c;

      bool needIterLimit = lhss.Count != 1 && bounds.Exists(bnd => (bnd.Virtues & ComprehensionExpr.BoundedPool.PoolVirtues.Finite) == 0);
      wr = CreateLabeledCode(doneLabel, wr);
      var wrOuter = wr;
      if (needIterLimit) {
        wr = CreateDoublingForLoop(iterLimit, 5, wr);
      }

      for (int i = 0; i < n; i++) {
        var bound = bounds[i];
        Contract.Assert((bound.Virtues & ComprehensionExpr.BoundedPool.PoolVirtues.Enumerable) != 0);  // if we have got this far, it must be an enumerable bound
        var bv = lhss[i];
        if (needIterLimit) {
          DeclareLocalVar(string.Format("{0}_{1}", iterLimit, i), null, null, bv.Usage, false, iterLimit, wr, Type.Int, false);
        }
        var tmpVar = idGenerator.FreshId("_assign_such_that_");
        TargetWriter collectionWriter;
        wr = CreateForeachLoop(tmpVar, GetCollectionEnumerationType(bound, bv), IdName(bv), bv.Type, false, bv.Tok, out collectionWriter, wr);
        CompileCollection(bound, bv, inLetExprBody, true, null, collectionWriter);
        if (needIterLimit) {
          var varName = string.Format("{0}_{1}", iterLimit, i);
          TargetWriter isZeroWriter;
          var thn = EmitIf(out isZeroWriter, false, wr);
          EmitIsZero(varName, isZeroWriter);
          EmitBreak(null, thn);
          EmitDecrementVar(varName, wr);
        }
      }
      TargetWriter guardWriter;
      var wBody = EmitIf(out guardWriter, false, wr);
      TrExpr(constraint, guardWriter, inLetExprBody);
      EmitBreak(doneLabel, wBody);
      // Java compiler throws unreachable error when absurd statement is written after unbounded for-loop, so we don't write it then.
      EmitAbsurd(string.Format("assign-such-that search produced no value (line {0})", debuginfoLine), wrOuter, needIterLimit);
    }

    protected interface ILvalue {
      void EmitRead(TargetWriter wr);

      /// Write an assignment expression (or equivalent) for the lvalue,
      /// returning a TargetWriter for the RHS.  IMPORTANT: Whoever calls
      /// EmitWrite is responsible for making the types match up (as by
      /// EmitCoercionIfNecessary), for example by going through the overload
      /// of EmitAssignment that takes an ILvalue.
      TargetWriter EmitWrite(TargetWriter wr);
    }

    protected ILvalue SimpleLvalue(Action<TargetWriter> action) {
      return new SimpleLvalueImpl(this, action);
    }

    protected ILvalue SimpleLvalue(Action<TargetWriter> lvalueAction, Action<TargetWriter> rvalueAction) {
      return new SimpleLvalueImpl(this, lvalueAction, rvalueAction);
    }

    protected ILvalue StringLvalue(string str) {
      return new SimpleLvalueImpl(this, wr => wr.Write(str));
    }

    protected ILvalue SuffixLvalue(Action<TargetWriter> action, string str, params object[] args) {
      return new SimpleLvalueImpl(this, wr => { action(wr); wr.Write(str, args); });
    }

    protected ILvalue EnclosedLvalue(string prefix, Action<TargetWriter> action, string suffixStr, params object[] suffixArgs) {
      return new SimpleLvalueImpl(this, wr => { wr.Write(prefix); action(wr); wr.Write(suffixStr, suffixArgs); });
    }

    protected ILvalue CoercedLvalue(ILvalue lvalue, Type/*?*/ from, Type/*?*/ to) {
      return new CoercedLvalueImpl(this, lvalue, from, to);
    }

    protected ILvalue GetterSetterLvalue(Action<TargetWriter> obj, string getterName, string setterName) {
      Contract.Requires(obj != null);
      Contract.Requires(getterName != null);
      Contract.Requires(setterName != null);
      return new GetterSetterLvalueImpl(obj, getterName, setterName);
    }

    private class SimpleLvalueImpl : ILvalue {
      private readonly Compiler Compiler;
      private readonly Action<TargetWriter> LvalueAction, RvalueAction;

      public SimpleLvalueImpl(Compiler compiler, Action<TargetWriter> action) {
        Compiler = compiler;
        LvalueAction = action;
        RvalueAction = action;
      }

      public SimpleLvalueImpl(Compiler compiler, Action<TargetWriter> lvalueAction, Action<TargetWriter> rvalueAction) {
        Compiler = compiler;
        LvalueAction = lvalueAction;
        RvalueAction = rvalueAction;
      }

      public void EmitRead(TargetWriter wr) {
        RvalueAction(wr);
      }

      public TargetWriter EmitWrite(TargetWriter wr) {
        Compiler.EmitAssignment(out var wLhs, null, out var wRhs, null, wr);
        LvalueAction(wLhs);
        return wRhs;
      }
    }

    private class CoercedLvalueImpl : ILvalue
    {
      private readonly Compiler Compiler;
      private readonly ILvalue lvalue;
      private readonly Type /*?*/ from;
      private readonly Type /*?*/ to;

      public CoercedLvalueImpl(Compiler compiler, ILvalue lvalue, Type/*?*/ from, Type/*?*/ to) {
        Compiler = compiler;
        this.lvalue = lvalue;
        this.from = from;
        this.to = to;
      }

      public void EmitRead(TargetWriter wr) {
        wr = Compiler.EmitCoercionIfNecessary(from, to, Bpl.Token.NoToken, wr);
        lvalue.EmitRead(wr);
      }

      public TargetWriter EmitWrite(TargetWriter wr) {
        return lvalue.EmitWrite(wr);
      }
    }

    private class GetterSetterLvalueImpl : ILvalue {
      private readonly Action<TargetWriter> obj;
      private readonly string getterName;
      private readonly string setterName;

      public GetterSetterLvalueImpl(Action<TargetWriter> obj, string getterName, string setterName) {
        this.obj = obj;
        this.getterName = getterName;
        this.setterName = setterName;
      }

      public void EmitRead(TargetWriter wr) {
        obj(wr);
        wr.Write($".{getterName}()");
      }

      public TargetWriter EmitWrite(TargetWriter wr) {
        obj(wr);
        wr.Write($".{setterName}(");
        var w = wr.Fork();
        wr.WriteLine(");");
        return w;
      }
    }

    ILvalue CreateLvalue(Expression lhs, TargetWriter wr) {
      Contract.Requires(lhs != null);
      Contract.Requires(wr != null);

      lhs = lhs.Resolved;
      if (lhs is IdentifierExpr) {
        var ll = (IdentifierExpr)lhs;
        return StringLvalue(IdName(ll.Var));
      } else if (lhs is MemberSelectExpr) {
        var ll = (MemberSelectExpr)lhs;
        Contract.Assert(!ll.Member.IsInstanceIndependentConstant);  // instance-independent const's don't have assignment statements
        var obj = StabilizeExpr(ll.Obj, "_obj", wr);
        var typeArgs = TypeArgumentInstantiation.ListFromMember(ll.Member, null, ll.TypeApplication_JustMember);
        return EmitMemberSelect(w => w.Write(obj), ll.Obj.Type, ll.Member, typeArgs, ll.TypeArgumentSubstitutionsWithParents(), lhs.Type,
          internalAccess: enclosingMethod is Constructor);
      } else if (lhs is SeqSelectExpr) {
        var ll = (SeqSelectExpr)lhs;
        var arr = StabilizeExpr(ll.Seq, "_arr", wr);
        var index = StabilizeExpr(ll.E0, "_index", wr);
        if (ll.Seq.Type.IsArrayType || ll.Seq.Type.AsSeqType != null) {
          index = ArrayIndexToNativeInt(index, ll.E0.Type);
        }
        return EmitArraySelectAsLvalue(arr, new List<string>() { index }, ll.Type);
      } else {
        var ll = (MultiSelectExpr)lhs;
        string arr = StabilizeExpr(ll.Array, "_arr", wr);
        var indices = new List<string>();
        int i = 0;
        foreach (var idx in ll.Indices) {
          var index = StabilizeExpr(idx, "_index" + i + "_", wr);
          index = ArrayIndexToNativeInt(index, idx.Type);
          indices.Add(index);
          i++;
        }
        return EmitArraySelectAsLvalue(arr, indices, ll.Type);
      }
    }

    /// <summary>
    /// If the given expression's value is stable, translate it and return the
    /// string form.  Otherwise, output code to evaluate the expression, then
    /// return a fresh variable bound to its value.
    /// </summary>
    /// <param name="e">An expression to evaluate</param>
    /// <param name="prefix">The prefix to give the fresh variable, if
    /// needed.</param>
    /// <param name="wr">A writer in a position to write statements
    /// evaluating the expression</param>
    /// <returns>A string giving the translated value as a stable
    /// expression</returns>
    /// <seealso cref="IsStableExpr"/>
    private string StabilizeExpr(Expression e, string prefix, TargetWriter wr) {
      if (IsStableExpr(e)) {
        var sw = new TargetWriter();
        TrParenExpr(e, sw, false);
        return sw.ToString();
      } else {
        var v = idGenerator.FreshId(prefix);
        DeclareLocalVar(v, null, null, Usage.Ordinary, e, false, wr, false);
        return v;
      }
    }

    /// <summary>
    /// Returns whether the given expression is <em>stable</em>, that is,
    /// whether its value is fixed over the course of the evaluation of an
    /// expression.  Note that anything that could be altered by a function call
    /// (say, the value of a non-constant field) is unstable.
    /// </summary>
    private bool IsStableExpr(Expression e) {
      if (e is IdentifierExpr || e is ThisExpr || e is LiteralExpr) {
        return true;
      } else if (e is MemberSelectExpr mse) {
        if (!IsStableExpr(mse.Obj)) {
          return false;
        }
        var member = mse.Member;
        if (member is ConstantField) {
          return true;
        } else if (member is SpecialField sf) {
          switch (sf.SpecialId) {
            case SpecialField.ID.ArrayLength:
            case SpecialField.ID.ArrayLengthInt:
            case SpecialField.ID.Floor:
            case SpecialField.ID.IsLimit:
            case SpecialField.ID.IsSucc:
            case SpecialField.ID.Offset:
            case SpecialField.ID.IsNat:
            case SpecialField.ID.Keys:
            case SpecialField.ID.Values:
            case SpecialField.ID.Items:
              return true;
            default:
              return false;
          }
        } else {
          return false;
        }
      } else if (e is ConcreteSyntaxExpression cse) {
        return IsStableExpr(cse.ResolvedExpression);
      } else {
        return false;
      }
    }

    /// <summary>
    /// Translate the right-hand side of an assignment.
    /// </summary>
    /// <param name="rhs">The RHS to translate</param>
    /// <param name="wr">The writer at the position for the translated RHS</param>
    /// <param name="wStmts">A writer at an earlier position where extra statements may be written</param>
    void TrRhs(AssignmentRhs rhs, TargetWriter wr, TargetWriter wStmts) {
      Contract.Requires(!(rhs is HavocRhs));
      Contract.Requires(wr != null);

      var tRhs = rhs as TypeRhs;

      if (tRhs == null) {
        var eRhs = (ExprRhs)rhs;  // it's not HavocRhs (by the precondition) or TypeRhs (by the "if" test), so it's gotta be ExprRhs
        TrExpr(eRhs.Expr, wr, false);
      } else {
        var nw = idGenerator.FreshId("_nw");
        var wRhs = DeclareLocalVar(nw, tRhs.Type, rhs.Tok, Usage.Ordinary, wStmts, false);
        TrTypeRhs(tRhs, wRhs);

        // Proceed with initialization
        if (tRhs.InitCall != null) {
          string q, n;
          if (tRhs.InitCall.Method is Constructor && tRhs.InitCall.Method.IsExtern(out q, out n)) {
            // initialization was done at the time of allocation
          } else {
            TrCallStmt(tRhs.InitCall, nw, wStmts);
          }
        } else if (tRhs.ElementInit != null) {
          // Compute the array-initializing function once and for all (as required by the language definition)
          string f = idGenerator.FreshId("_arrayinit");
          DeclareLocalVar(f, tRhs.ElementInit.Type, tRhs.ElementInit.tok, Usage.Ordinary, tRhs.ElementInit, false, wStmts, false);
          // Build a loop nest that will call the initializer for all indices
          var indices = Translator.Map(Enumerable.Range(0, tRhs.ArrayDimensions.Count), ii => idGenerator.FreshId("_arrayinit_" + ii));
          var w = wStmts;
          for (var d = 0; d < tRhs.ArrayDimensions.Count; d++) {
            string len, pre, post;
            GetSpecialFieldInfo(SpecialField.ID.ArrayLength, tRhs.ArrayDimensions.Count == 1 ? null : (object)d, tRhs.Type, out len, out pre, out post);
            var bound = string.Format("{0}{1}{2}{3}", pre, nw, len == "" ? "" : "." + len, post);
            w = CreateForLoop(indices[d], bound, w);
          }
          var eltRhs = string.Format("{0}{2}({1})", f, Util.Comma(indices, idx => ArrayIndexToInt(idx, Type.Int)), LambdaExecute);
          var wArray = EmitArrayUpdate(indices, eltRhs, tRhs.EType, w);
          wArray.Write(nw);
          EndStmt(w);
        } else if (tRhs.InitDisplay != null) {
          var ii = 0;
          foreach (var v in tRhs.InitDisplay) {
            var wArray = EmitArrayUpdate(new List<string> { ii.ToString() }, v, wStmts);
            wArray.Write(nw);
            EndStmt(wStmts);
            ii++;
          }
        }

        // Assign to the final LHS
        wr.Write(nw);
      }
    }

    private static Type TypeOfLhs(Expression lhs) {
      Contract.Requires(lhs != null);
      if (lhs is IdentifierExpr) {
        var e = (IdentifierExpr)lhs;
        return e.Var.Type;
      } else if (lhs is MemberSelectExpr) {
        var e = (MemberSelectExpr)lhs;
        return Resolver.SubstType(((Field)e.Member).Type, e.TypeArgumentSubstitutionsWithParents());
      } else if (lhs is SeqSelectExpr) {
        var e = (SeqSelectExpr)lhs;
        return e.Seq.Type.NormalizeExpand().TypeArgs[0];
      } else {
        var e = (MultiSelectExpr)lhs;
        return e.Array.Type.NormalizeExpand().TypeArgs[0];
      }
    }

    // to do: Make Type an abstract property of AssignmentRhs.  Unfortunately, this would first require convincing Microsoft that it makes sense for a base class to have a property that's only settable in some subclasses.  Until then, let it be known that Java's "properties" (i.e. getter/setter pairs) are more powerful >:-)
    private static Type TypeOfRhs(AssignmentRhs rhs) {
      if (rhs is TypeRhs tRhs) {
        return tRhs.Type;
      } else if (rhs is ExprRhs eRhs) {
        return eRhs.Expr.Type;
      } else {
        return null;
      }
    }

    void TrCallStmt(CallStmt s, string receiverReplacement, TargetWriter wr) {
      Contract.Requires(s != null);
      Contract.Assert(s.Method != null);  // follows from the fact that stmt has been successfully resolved

      if (s.Method == enclosingMethod && enclosingMethod.IsTailRecursive) {
        // compile call as tail-recursive

        // assign the actual in-parameters to temporary variables
        var inTmps = new List<string>();
        var inTypes = new List<Type/*?*/>();
        if (receiverReplacement != null) {
          // TODO:  What to do here?  When does this happen, what does it mean?
        } else if (!s.Method.IsStatic) {
          string inTmp = idGenerator.FreshId("_in");
          inTmps.Add(inTmp);
          inTypes.Add(null);
          DeclareLocalVar(inTmp, null, null, Usage.Ordinary, s.Receiver, false, wr, false);
        }
        for (int i = 0; i < s.Method.Ins.Count; i++) {
          Formal p = s.Method.Ins[i];
          if (!p.IsReallyGhost) {
            string inTmp = idGenerator.FreshId("_in");
            inTmps.Add(inTmp);
            inTypes.Add(s.Args[i].Expr.Type);
            DeclareLocalVar(inTmp, s.Args[i].Expr.Type, p.tok, p.Usage, s.Args[i].Expr, false, wr, false);
          }
        }
        // Now, assign to the formals
        int n = 0;
        if (!s.Method.IsStatic) {
          wr.Write("_this = ");
          TargetWriter wRHS;
          if (thisContext == null) {
            wRHS = wr;
          } else {
            var instantiatedType = Resolver.SubstType(s.Receiver.Type, thisContext.ParentFormalTypeParametersToActuals);
            wRHS = EmitCoercionIfNecessary(instantiatedType, UserDefinedType.FromTopLevelDecl(s.Tok, thisContext), s.Tok, wr);
          }
          wRHS.Write(inTmps[n]);
          EndStmt(wr);
          n++;
        }
        foreach (var p in s.Method.Ins) {
          if (!p.IsReallyGhost) {
            EmitAssignment(IdName(p), p.Type, inTmps[n], inTypes[n], wr);
            n++;
          }
        }
        Contract.Assert(n == inTmps.Count);
        // finally, the jump back to the head of the method
        EmitJumpToTailCallStart(wr);

      } else {
        // compile call as a regular call

        var lvalues = new List<ILvalue>();  // contains an entry for each non-ghost formal out-parameter, but the entry is null if the actual out-parameter is ghost
        Contract.Assert(s.Lhs.Count == s.Method.Outs.Count);
        for (int i = 0; i < s.Method.Outs.Count; i++) {
          Formal p = s.Method.Outs[i];
          if (!p.IsReallyGhost) {
            var lhs = s.Lhs[i].Resolved;
            if (lhs is IdentifierExpr lhsIE && lhsIE.Var.IsReallyGhost) {
              lvalues.Add(null);
            } else if (lhs is MemberSelectExpr lhsMSE && lhsMSE.Member.IsGhost) {
              lvalues.Add(null);
            } else {
              lvalues.Add(CreateLvalue(s.Lhs[i], wr));
            }
          }
        }
        var outTmps = new List<string>();  // contains a name for each non-ghost formal out-parameter
        var outTypes = new List<Type>();  // contains a type for each non-ghost formal out-parameter
        var outFormalTypes = new List<Type>(); // contains the type as it appears in the method type (possibly includes type parameters)
        var outLhsTypes = new List<Type>(); // contains the type as it appears on the LHS (may give types for those parameters)
        for (int i = 0; i < s.Method.Outs.Count; i++) {
          Formal p = s.Method.Original.Outs[i];
          if (!p.IsReallyGhost) {
            string target = idGenerator.FreshId("_out");
            outTmps.Add(target);
            var instantiatedType = Resolver.SubstType(p.Type, s.MethodSelect.TypeArgumentSubstitutionsWithParents());
            Type type;
            if (NeedsCastFromTypeParameter && IsCoercionNecessary(p.Type, instantiatedType)) {
              //
              // The type of the parameter will differ from the LHS type in a
              // situation like this:
              //
              //   method Gimmie<R(0)>() returns (r: R) { }
              //
              //   var a : int := Gimmie();
              //
              // The method Gimme will be compiled down to Go (or JavaScript)
              // as a function which returns any value (some details omitted):
              //
              //   func Gimmie(ty _dafny.Type) interface{} {
              //     return ty.Default()
              //   }
              //
              // If we naively translate, we get a type error:
              //
              //   var lhs int = Gimmie(_dafny.IntType) // error!
              //
              // Fortunately, we have the information at hand to do better.  The
              // LHS does have the actual final type (int in this case), and the
              // out parameter on the method tells us the compiled type
              // returned.  Therefore what we want to do is this:
              //
              //   var lhs dafny.Int
              //   var _out interface{}
              //
              //   _out = Gimmie(dafny.IntType)
              //
              //   lhs = _out.(int) // type cast
              //
              // All we have to do now is declare the out variable with the type
              // from the parameter; later we'll do the type cast.
              //
              // None of this is necessary if the language supports parametric
              // functions to begin with (C#) or has dynamic typing so none of
              // this comes up (JavaScript), so we only do this if
              // NeedsCastFromTypeParameter is on.
              type = p.Type;
            } else {
              type = instantiatedType;
            }
            if (s.Method.IsExtern(out _, out _)) {
              type = NativeForm(type);
            }
            outTypes.Add(type);
            outFormalTypes.Add(p.Type);
            outLhsTypes.Add(s.Lhs[i].Type);
            DeclareLocalVar(target, type, s.Lhs[i].tok, p.Usage, false, null, wr, true);
          }
        }
        Contract.Assert(lvalues.Count == outTmps.Count);

        bool customReceiver = !(s.Method.EnclosingClass is TraitDecl) && NeedsCustomReceiver(s.Method);
        Contract.Assert(receiverReplacement == null || !customReceiver);  // What would be done in this case? It doesn't ever happen, right?

        var returnStyleOuts = UseReturnStyleOuts(s.Method, outTmps.Count);
        var returnStyleOutCollector = outTmps.Count > 1 && returnStyleOuts && !SupportsMultipleReturns ? idGenerator.FreshId("_outcollector") : null;
        if (returnStyleOutCollector != null) {
          DeclareSpecificOutCollector(returnStyleOutCollector, wr, outFormalTypes, outLhsTypes);
        } else if (outTmps.Count > 0 && returnStyleOuts) {
          wr.Write("{0} = ", Util.Comma(outTmps));
        }
        var wrOrig = wr;
        if (returnStyleOutCollector == null && outTmps.Count == 1 && returnStyleOuts) {
          var instantiatedFromType = Resolver.SubstType(outFormalTypes[0], s.MethodSelect.TypeArgumentSubstitutionsWithParents());
          var toType = outTypes[0];
          wr = EmitDowncastIfNecessary(instantiatedFromType, toType, s.Tok, wr);
        }
        var protectedName = IdName(s.Method);
        if (receiverReplacement != null) {
          wr.Write(IdProtect(receiverReplacement));
          wr.Write(ClassAccessor);
        } else if (customReceiver) {
          wr.Write(TypeName_Companion(s.Receiver.Type, wr, s.Tok, s.Method));
          wr.Write(ClassAccessor);
        } else if (!s.Method.IsStatic) {
          TrParenExpr(s.Receiver, wr, false);
          wr.Write(ClassAccessor);
        } else if (s.Method.IsExtern(out var qual, out var compileName) && qual != null) {
          wr.Write("{0}{1}", qual, ModuleSeparator);
          protectedName = compileName;
        } else {
          wr.Write(TypeName_Companion(s.Receiver.Type, wr, s.Tok, s.Method));
          wr.Write(ModuleSeparator);
        }
        var typeArgs = CombineAllTypeArguments(s.Method, s.MethodSelect.TypeApplication_AtEnclosingClass, s.MethodSelect.TypeApplication_JustMember);
        EmitNameAndActualTypeArgs(protectedName, TypeArgumentInstantiation.ToActuals(ForTypeParameters(typeArgs, s.Method, false)), s.Tok, wr);
        wr.Write("(");
        var sep = "";
        EmitTypeDescriptorsActuals(ForTypeDescriptors(typeArgs, s.Method, false), s.Tok, wr, ref sep);
        if (customReceiver) {
          wr.Write(sep);
          var w = EmitCoercionIfNecessary(s.Receiver.Type, UserDefinedType.UpcastToMemberEnclosingType(s.Receiver.Type, s.Method), s.Tok, wr);
          TrExpr(s.Receiver, w, false);
          sep = ", ";
        }
        for (int i = 0; i < s.Method.Ins.Count; i++) {
          Formal p = s.Method.Ins[i];
          if (!p.IsReallyGhost) {
            wr.Write(sep);
            var fromType = s.Args[i].Expr.Type;
            var toType = s.Method.Ins[i].Type;
            var instantiatedToType = Resolver.SubstType(toType, s.MethodSelect.TypeArgumentSubstitutionsWithParents());
            // Order of coercions is important here: EmitCoercionToNativeForm may coerce into a type we're unaware of, so it *has* to be last
            var w = EmitCoercionIfNecessary(fromType, toType, s.Tok, wr);
            w = EmitDowncastIfNecessary(fromType, instantiatedToType, s.Tok, w);
            if (s.Method.IsExtern(out _, out _)) {
              w = EmitCoercionToNativeForm(toType, s.Tok, w);
            }
            TrExpr(s.Args[i].Expr, w, false);
            sep = ", ";
          }
        }

        if (!returnStyleOuts) {
          foreach (var outTmp in outTmps) {
            wr.Write(sep);
            EmitActualOutArg(outTmp, wr);
            sep = ", ";
          }
        }
        wr.Write(')');
        wr = wrOrig;
        EndStmt(wr);
        if (returnStyleOutCollector != null) {
          EmitCastOutParameterSplits(returnStyleOutCollector, outTmps, wr, outFormalTypes, outLhsTypes, s.Tok);
        }

        // assign to the actual LHSs
        for (int j = 0, l = 0; j < s.Method.Outs.Count; j++) {
          var p = s.Method.Outs[j];
          if (!p.IsReallyGhost) {
            var lvalue = lvalues[l];
            if (lvalue != null) {
              // The type information here takes care both of implicit upcasts and
              // implicit downcasts from type parameters (see above).
              TargetWriter wRhs = EmitAssignment(lvalue, s.Lhs[j].Type, outTypes[l], wr);
              if (s.Method.IsExtern(out _, out _)) {
                wRhs = EmitCoercionFromNativeForm(p.Type, s.Tok, wRhs);
              }
              wRhs.Write(outTmps[l]);
              // Coercion from the out type to the LHS type is the responsibility
              // of the EmitAssignment above
            }
            l++;
          }
        }
      }
    }

    /// <summary>
    /// Before calling TrAssignmentRhs(rhs), the caller must have spilled the let variables declared in "tp".
    /// </summary>
    void TrTypeRhs(TypeRhs tp, TargetWriter wr) {
      Contract.Requires(tp != null);
      Contract.Requires(wr != null);

      if (tp.ArrayDimensions == null) {
        var initCall = tp.InitCall != null && tp.InitCall.Method is Constructor ? tp.InitCall : null;
        EmitNew(tp.EType, tp.Tok, initCall, wr);
      } else if (tp.ElementInit != null || tp.InitDisplay != null) {
        EmitNewArray(tp.EType, tp.Tok, tp.ArrayDimensions, false, wr);
      } else {
        // If an initializer is not known, the only way the verifier would have allowed this allocation
        // is if the requested size is 0.
        EmitNewArray(tp.EType, tp.Tok, tp.ArrayDimensions, tp.EType.HasCompilableValue, wr);
      }
    }

    protected void TrStmtList(List<Statement> stmts, TargetWriter writer){
      Contract.Requires(cce.NonNullElements(stmts));
      Contract.Requires(writer != null);
      foreach (Statement ss in stmts) {
        // label:        // if any
        //   <prelude>   // filled via copyInstrWriters -- copies out-parameters used in letexpr to local variables
        //   ss          // translation of ss has side effect of filling the top copyInstrWriters
        var w = writer;
        if (ss.Labels != null) {
          w = CreateLabeledCode(ss.Labels.Data.AssignUniqueId(idGenerator), w);
        }
        var prelude = w.ForkSection();
        copyInstrWriters.Push(prelude);
        TrStmt(ss, w);
        copyInstrWriters.Pop();
      }
    }

    void TrLocalVar(IVariable v, bool alwaysInitialize, TargetWriter wr) {
      Contract.Requires(v != null);
      if (v.IsReallyGhost) {
        // only emit non-ghosts (we get here only for local variables introduced implicitly by call statements)
        return;
      }
      DeclareLocalVar(IdName(v), v.Type, v.Tok, v.Usage, false, alwaysInitialize ? DefaultValue(v.Type, wr, v.Tok, v.Usage, true) : null, wr, true);
    }

    TargetWriter MatchCasePrelude(string source, UserDefinedType sourceType, DatatypeCtor ctor, List<BoundVar> arguments, int caseIndex, int caseCount, TargetWriter wr) {
      Contract.Requires(source != null);
      Contract.Requires(sourceType != null);
      Contract.Requires(ctor != null);
      Contract.Requires(cce.NonNullElements(arguments));
      Contract.Requires(0 <= caseIndex && caseIndex < caseCount);
      // if (source.is_Ctor0) {
      //   FormalType f0 = ((Dt_Ctor0)source._D).a0;
      //   ...
      var lastCase = caseIndex == caseCount - 1;
      TargetWriter w;
      if (lastCase) {
        // Need to avoid if (true) because some languages (Go, someday Java)
        // pretend that an if (true) isn't a certainty, leading to a complaint
        // about a missing return statement
        w = wr.NewBlock("", null, BlockTargetWriter.BraceStyle.Nothing);
      } else {
        TargetWriter guardWriter;
        w = EmitIf(out guardWriter, !lastCase, wr);
        EmitConstructorCheck(source, ctor, guardWriter);
      }

      int k = 0;  // number of processed non-ghost arguments
      for (int m = 0; m < ctor.Formals.Count; m++) {
        Formal arg = ctor.Formals[m];
        if (!arg.IsReallyGhost) {
          BoundVar bv = arguments[m];
          // FormalType f0 = ((Dt_Ctor0)source._D).a0;
          var sw = DeclareLocalVar(IdName(bv), bv.Type, bv.Tok, bv.Usage, w, false);
          EmitDestructor(source, arg, k, ctor, sourceType.TypeArgs, bv.Type, sw);
          k++;
        }
      }
      return w;
    }

    // ----- Expression ---------------------------------------------------------------------------

    /// <summary>
    /// Before calling TrParenExpr(expr), the caller must have spilled the let variables declared in "expr".
    /// </summary>
    protected void TrParenExpr(string prefix, Expression expr, TargetWriter wr, bool inLetExprBody) {
      Contract.Requires(prefix != null);
      Contract.Requires(expr != null);
      Contract.Requires(wr != null);
      wr.Write(prefix);
      TrParenExpr(expr, wr, inLetExprBody);
    }

    /// <summary>
    /// Before calling TrParenExpr(expr), the caller must have spilled the let variables declared in "expr".
    /// </summary>
    protected void TrParenExpr(Expression expr, TargetWriter wr, bool inLetExprBody) {
      Contract.Requires(expr != null);
      Contract.Requires(wr != null);
      wr.Write("(");
      TrExpr(expr, wr, inLetExprBody);
      wr.Write(")");
    }

    /// <summary>
    /// Before calling TrExprList(exprs), the caller must have spilled the let variables declared in expressions in "exprs".
    /// </summary>
    protected void TrExprList(List<Expression> exprs, TargetWriter wr, bool inLetExprBody, Type/*?*/ type = null) {
      Contract.Requires(cce.NonNullElements(exprs));
      wr.Write("(");
      string sep = "";
      foreach (Expression e in exprs) {
        wr.Write(sep);
        TargetWriter w;
        if (type != null) {
          w = wr.Fork();
          w = EmitCoercionIfNecessary(e.Type, type, e.tok, w);
        } else {
          w = wr;
        }
        TrExpr(e, w, inLetExprBody);
        sep = ", ";
      }
      wr.Write(")");
    }

    protected virtual void WriteCast(string s, TargetWriter wr) { }

    /// <summary>
    /// Before calling TrExpr(expr), the caller must have spilled the let variables declared in "expr".
    /// </summary>
    protected void TrExpr(Expression expr, TargetWriter wr, bool inLetExprBody) {
      Contract.Requires(expr != null);
      Contract.Requires(wr != null);

      if (expr is LiteralExpr) {
        LiteralExpr e = (LiteralExpr)expr;
        EmitLiteralExpr(wr, e);

      } else if (expr is ThisExpr) {
        if (thisContext != null) {
          var instantiatedType = Resolver.SubstType(expr.Type, thisContext.ParentFormalTypeParametersToActuals);
          wr = EmitCoercionIfNecessary(UserDefinedType.FromTopLevelDecl(expr.tok, thisContext), instantiatedType, expr.tok, wr);
        }
        EmitThis(wr);

      } else if (expr is IdentifierExpr) {
        var e = (IdentifierExpr)expr;
        if (e.Var is Formal && inLetExprBody && !((Formal)e.Var).InParam) {
          // out param in letExpr body, need to copy it to a temp since
          // letExpr body is translated to an anonymous function that doesn't
          // allow out parameters
          var name = string.Format("_pat_let_tv{0}", GetUniqueAstNumber(e));
          wr.Write(name);
          DeclareLocalVar(name, null, null, e.Var.Usage, false, IdName(e.Var), copyInstrWriters.Peek(), e.Type, false);
        } else
        {
          var must_deref = (e.Var is LocalVariable && e.Var.Usage.IsSharedKind);
          if (must_deref)
          {
            wr.Write("(*" + IdName(e.Var) + ")"); // XXX(travis): C++-specific
          }
          else
          {
            wr.Write(IdName(e.Var));
          }
        }
      } else if (expr is SetDisplayExpr) {
        var e = (SetDisplayExpr)expr;
        EmitCollectionDisplay(e.Type.AsSetType, e.tok, e.Elements, inLetExprBody, wr);

      } else if (expr is MultiSetDisplayExpr) {
        var e = (MultiSetDisplayExpr)expr;
        EmitCollectionDisplay(e.Type.AsMultiSetType, e.tok, e.Elements, inLetExprBody, wr);

      } else if (expr is SeqDisplayExpr) {
        var e = (SeqDisplayExpr)expr;
        EmitCollectionDisplay(e.Type.AsSeqType, e.tok, e.Elements, inLetExprBody, wr);

      } else if (expr is MapDisplayExpr) {
        var e = (MapDisplayExpr)expr;
        EmitMapDisplay(e.Type.AsMapType, e.tok, e.Elements, inLetExprBody, wr);

      } else if (expr is MemberSelectExpr) {
        MemberSelectExpr e = (MemberSelectExpr)expr;
        SpecialField sf = e.Member as SpecialField;
        if (sf != null) {
          string compiledName, preStr, postStr;
          GetSpecialFieldInfo(sf.SpecialId, sf.IdParam, e.Obj.Type, out compiledName, out preStr, out postStr);
          wr.Write(preStr);

          if (sf.IsStatic && !SupportsStaticsInGenericClasses && sf.EnclosingClass.TypeArgs.Count != 0) {
            var typeArgs = e.TypeApplication_AtEnclosingClass;
            Contract.Assert(typeArgs.Count == sf.EnclosingClass.TypeArgs.Count);
            wr.Write("{0}.", TypeName_Companion(e.Obj.Type, wr, e.tok, sf));
            EmitNameAndActualTypeArgs(IdName(e.Member), typeArgs, e.tok, wr);
            wr.Write("(");
            var tas = TypeArgumentInstantiation.ListFromClass(sf.EnclosingClass, typeArgs);
            EmitTypeDescriptorsActuals(tas, e.tok, wr);
            wr.Write(")");
          } else {
            void writeObj(TargetWriter w) {
              //Contract.Assert(!sf.IsStatic);
              w = EmitCoercionIfNecessary(e.Obj.Type, UserDefinedType.UpcastToMemberEnclosingType(e.Obj.Type, e.Member), e.tok, w);
              TrParenExpr(e.Obj, w, inLetExprBody);
            }

            var typeArgs = CombineAllTypeArguments(e.Member, e.TypeApplication_AtEnclosingClass, e.TypeApplication_JustMember);
            EmitMemberSelect(writeObj, e.Obj.Type, e.Member, typeArgs, e.TypeArgumentSubstitutionsWithParents(), expr.Type).EmitRead(wr);
          }

          wr.Write(postStr);
        } else {
          var typeArgs = CombineAllTypeArguments(e.Member, e.TypeApplication_AtEnclosingClass, e.TypeApplication_JustMember);
          var typeMap = e.TypeArgumentSubstitutionsWithParents();
          var customReceiver = NeedsCustomReceiver(e.Member) && !(e.Member.EnclosingClass is TraitDecl);
          if (!customReceiver && !e.Member.IsStatic) {
            Action<TargetWriter> obj;
            // The eta conversion here is to avoid capture of the receiver, because the call to EmitMemberSelect below may generate
            // a lambda expression in the target language.
            if (e.Member is Function && typeArgs.Count != 0) {
              // need to eta-expand wrap the receiver
              var etaReceiver = idGenerator.FreshId("_eta_this");
              wr = CreateIIFE_ExprBody(etaReceiver, e.Obj.Type, e.Obj.tok, e.Obj, inLetExprBody, Resolver.SubstType(e.Type, typeMap), e.tok, wr);
              obj = w => w.Write(etaReceiver);
            } else {
              obj = w => TrExpr(e.Obj, w, inLetExprBody);
            }
            EmitMemberSelect(obj, e.Obj.Type, e.Member, typeArgs, typeMap, expr.Type).EmitRead(wr);
          } else {
            string customReceiverName = null;
            if (customReceiver && e.Member is Function) {
              // need to eta-expand wrap the receiver
              customReceiverName = idGenerator.FreshId("_eta_this");
              wr = CreateIIFE_ExprBody(customReceiverName, e.Obj.Type, e.Obj.tok, e.Obj, inLetExprBody, Resolver.SubstType(e.Type, typeMap), e.tok, wr);
            }
            Action<TargetWriter> obj = w => w.Write(TypeName_Companion(e.Obj.Type, wr, e.tok, e.Member));
            EmitMemberSelect(obj, e.Obj.Type, e.Member, typeArgs, typeMap, expr.Type, customReceiverName).EmitRead(wr);
          }
        }
      } else if (expr is SeqSelectExpr) {
        SeqSelectExpr e = (SeqSelectExpr)expr;
        Contract.Assert(e.Seq.Type != null);
        if (e.Seq.Type.IsArrayType) {
          if (e.SelectOne) {
            Contract.Assert(e.E0 != null && e.E1 == null);
            var w = EmitArraySelect(new List<Expression>() { e.E0 }, e.Type, inLetExprBody, wr);
            TrParenExpr(e.Seq, w, inLetExprBody);
          } else {
            EmitSeqSelectRange(e.Seq, e.E0, e.E1, true, inLetExprBody, wr);
          }
        } else if (e.SelectOne) {
          Contract.Assert(e.E0 != null && e.E1 == null);
          EmitIndexCollectionSelect(e.Seq, e.E0, inLetExprBody, wr);
        } else {
          EmitSeqSelectRange(e.Seq, e.E0, e.E1, false, inLetExprBody, wr);
        }
      } else if (expr is SeqConstructionExpr) {
        var e = (SeqConstructionExpr)expr;
        EmitSeqConstructionExpr(e, inLetExprBody, wr);
      } else if (expr is MultiSetFormingExpr) {
        var e = (MultiSetFormingExpr)expr;
        EmitMultiSetFormingExpr(e, inLetExprBody, wr);
      } else if (expr is MultiSelectExpr) {
        MultiSelectExpr e = (MultiSelectExpr)expr;
        WriteCast(TypeName(e.Type.NormalizeExpand(), wr, e.tok), wr);
        var w = EmitArraySelect(e.Indices, e.Type, inLetExprBody, wr);
        TrParenExpr(e.Array, w, inLetExprBody);

      } else if (expr is SeqUpdateExpr) {
        SeqUpdateExpr e = (SeqUpdateExpr)expr;
        if (e.ResolvedUpdateExpr != null) {
          TrExpr(e.ResolvedUpdateExpr, wr, inLetExprBody);
        } else {
          var collectionType = e.Type.AsCollectionType;
          Contract.Assert(collectionType != null);
          EmitIndexCollectionUpdate(e.Seq, e.Index, e.Value, collectionType, inLetExprBody, wr);
        }

      } else if (expr is FunctionCallExpr) {
        FunctionCallExpr e = (FunctionCallExpr)expr;
        if (e.Function is SpecialFunction) {
          CompileSpecialFunctionCallExpr(e, wr, inLetExprBody, TrExpr);
        } else {
          CompileFunctionCallExpr(e, wr, inLetExprBody, TrExpr);
        }

      } else if (expr is ApplyExpr) {
        var e = expr as ApplyExpr;
        EmitApplyExpr(e.Function.Type, e.tok, e.Function, e.Args, inLetExprBody, wr);

      } else if (expr is DatatypeValue) {
        var dtv = (DatatypeValue)expr;
        Contract.Assert(dtv.Ctor != null);  // since dtv has been successfully resolved

        var wrArgumentList = new TargetWriter();
        string sep = "";
        for (int i = 0; i < dtv.Arguments.Count; i++) {
          var formal = dtv.Ctor.Formals[i];
          if (!formal.IsReallyGhost) {
            wrArgumentList.Write(sep);
            var w = EmitCoercionIfNecessary(from:dtv.Arguments[i].Type, to:dtv.Ctor.Formals[i].Type, tok:dtv.tok, wr:wrArgumentList);
            TrExpr(dtv.Arguments[i], w, inLetExprBody);
            sep = ", ";
          }
        }
        EmitDatatypeValue(dtv, wrArgumentList.ToString(), wr);

      } else if (expr is OldExpr) {
        Contract.Assert(false); throw new cce.UnreachableException();  // 'old' is always a ghost

      } else if (expr is UnaryOpExpr) {
        var e = (UnaryOpExpr)expr;
        switch (e.Op) {
          case UnaryOpExpr.Opcode.Not:
            if (e.Type.IsBitVectorType) {
              var bvType = e.Type.AsBitVectorType;
              var wrTruncOperand = EmitBitvectorTruncation(bvType, false, wr);
              EmitUnaryExpr(ResolvedUnaryOp.BitwiseNot, e.E, inLetExprBody, wrTruncOperand);
            } else {
              EmitUnaryExpr(ResolvedUnaryOp.BoolNot, e.E, inLetExprBody, wr);
            }
            break;
          case UnaryOpExpr.Opcode.Cardinality:
            EmitUnaryExpr(ResolvedUnaryOp.Cardinality, e.E, inLetExprBody, wr);
            break;
          default:
            Contract.Assert(false); throw new cce.UnreachableException();  // unexpected unary expression
        }

      } else if (expr is ConversionExpr) {
        var e = (ConversionExpr)expr;
        EmitConversionExpr(e, inLetExprBody, wr);

      } else if (expr is BinaryExpr) {
        var e = (BinaryExpr)expr;

        if (IsComparisonToZero(e, out var arg, out var sign, out var negated) &&
            CompareZeroUsingSign(arg.Type)) {
          // Transform e.g. x < BigInteger.Zero into x.Sign == -1
          var w = EmitSign(arg.Type, wr);
          TrParenExpr(arg, w, inLetExprBody);
          wr.Write(negated ? " != " : " == ");
          wr.Write(sign);
        } else {
          string opString, preOpString, postOpString, callString, staticCallString;
          bool reverseArguments, truncateResult, convertE1_to_int;
          CompileBinOp(e.ResolvedOp, e.E0, e.E1, e.tok, expr.Type,
            out opString,
            out preOpString,
            out postOpString,
            out callString,
            out staticCallString,
            out reverseArguments,
            out truncateResult,
            out convertE1_to_int,
            wr);

          if (truncateResult && e.Type.IsBitVectorType) {
            wr = EmitBitvectorTruncation(e.Type.AsBitVectorType, true, wr);
          }
          var e0 = reverseArguments ? e.E1 : e.E0;
          var e1 = reverseArguments ? e.E0 : e.E1;
          if (opString != null) {
            var nativeType = AsNativeType(e.Type);
            string nativeName = null, literalSuffix = null;
            bool needsCast = false;
            if (nativeType != null) {
              GetNativeInfo(nativeType.Sel, out nativeName, out literalSuffix, out needsCast);
            }
            if (needsCast) {
              wr.Write("(" + nativeName + ")(");
            }
            wr.Write(preOpString);
            TrParenExpr(e0, wr, inLetExprBody);
            wr.Write(" {0} ", opString);
            if (convertE1_to_int) {
              EmitExprAsInt(e1, inLetExprBody, wr);
            } else {
              TrParenExpr(e1, wr, inLetExprBody);
            }
            if (needsCast) {
              wr.Write(")");
            }
            wr.Write(postOpString);
          } else if (callString != null) {
            wr.Write(preOpString);
            TrParenExpr(e0, wr, inLetExprBody);
            wr.Write(".{0}(", callString);
            if (convertE1_to_int) {
              EmitExprAsInt(e1, inLetExprBody, wr);
            } else {
              TrParenExpr(e1, wr, inLetExprBody);
            }
            wr.Write(")");
            wr.Write(postOpString);
          } else if (staticCallString != null) {
            wr.Write(preOpString);
            wr.Write("{0}(", staticCallString);
            TrExpr(e0, wr, inLetExprBody);
            wr.Write(", ");
            TrExpr(e1, wr, inLetExprBody);
            wr.Write(")");
            wr.Write(postOpString);
          }
        }
      } else if (expr is TernaryExpr) {
        Contract.Assume(false);  // currently, none of the ternary expressions is compilable

      } else if (expr is LetExpr) {
        var e = (LetExpr)expr;
        if (e.Exact) {
          // The Dafny "let" expression
          //    var Pattern(x,y) := G; E
          // is translated into C# as:
          //    LamLet(G, tmp =>
          //      LamLet(dtorX(tmp), x =>
          //      LamLet(dtorY(tmp), y => E)))
          Contract.Assert(e.LHSs.Count == e.RHSs.Count);  // checked by resolution
          var w = wr;
          for (int i = 0; i < e.LHSs.Count; i++) {
            var lhs = e.LHSs[i];
            if (Contract.Exists(lhs.Vars, bv => !bv.IsReallyGhost)) {
              var rhsName = string.Format("_pat_let{0}_{1}", GetUniqueAstNumber(e), i);
              w = CreateIIFE_ExprBody(rhsName, e.RHSs[i].Type, e.RHSs[i].tok, e.RHSs[i], inLetExprBody, e.Body.Type, e.Body.tok, w);
              w = TrCasePattern(lhs, rhsName, e.RHSs[i].Type, e.Body.Type, w);
            }
          }
          TrExpr(e.Body, w, true);
        } else if (e.BoundVars.All(bv => bv.IsGhost)) {
          // The Dafny "let" expression
          //    ghost var x,y :| Constraint; E
          // is compiled just like E is, because the resolver has already checked that x,y (or other ghost variables, for that matter) don't
          // occur in E (moreover, the verifier has checked that values for x,y satisfying Constraint exist).
          TrExpr(e.Body, wr, inLetExprBody);
        } else {
          // The Dafny "let" expression
          //    var x,y :| Constraint; E
          // is translated into C# as:
          //    LamLet(0, dummy => {  // the only purpose of this construction here is to allow us to add some code inside an expression in C#
          //        var x,y;
          //        // Embark on computation that fills in x,y according to Constraint; the computation stops when the first
          //        // such value is found, but since the verifier checks that x,y follows uniquely from Constraint, this is
          //        // not a source of nondeterminancy.
          //        return E;
          //      })
          Contract.Assert(e.RHSs.Count == 1);  // checked by resolution
          var missingBounds = ComprehensionExpr.BoolBoundedPool.MissingBounds(e.BoundVars.ToList<BoundVar>(), e.Constraint_Bounds, ComprehensionExpr.BoundedPool.PoolVirtues.Enumerable);
          if (missingBounds.Count != 0) {
            foreach (var bv in missingBounds) {
              Error(e.tok, "this let-such-that expression is too advanced for the current compiler; Dafny's heuristics cannot find any bound for variable '{0}'", wr, bv.Name);
            }
          } else {
            var w = CreateIIFE1(0, e.Body.Type, e.Body.tok, "_let_dummy_" + GetUniqueAstNumber(e), wr);
            foreach (var bv in e.BoundVars) {
              DeclareLocalVar(IdName(bv), bv.Type, bv.tok, bv.Usage, false, PlaceboValue(bv.Type, wr, bv.tok, bv.Usage, true), w, false);
            }
            TrAssignSuchThat(new List<IVariable>(e.BoundVars).ConvertAll(bv => (IVariable)bv), e.RHSs[0], e.Constraint_Bounds, e.tok.line, w, inLetExprBody);
            EmitReturnExpr(e.Body, e.Body.Type, true, w, false);
          }
        }
      } else if (expr is MatchExpr) {
        var e = (MatchExpr)expr;
        // ((System.Func<SourceType, TargetType>)((SourceType _source) => {
        //   if (source.is_Ctor0) {
        //     FormalType f0 = ((Dt_Ctor0)source._D).a0;
        //     ...
        //     return Body0;
        //   } else if (...) {
        //     ...
        //   } else if (true) {
        //     ...
        //   }
        // }))(src)

        string source = idGenerator.FreshId("_source");
        var w = CreateLambda(new List<Type>() { e.Source.Type }, e.tok, new List<string>() { source }, e.Type, wr);

        if (e.Cases.Count == 0) {
          // the verifier would have proved we never get here; still, we need some code that will compile
          EmitAbsurd(null, w);
        } else {
          int i = 0;
          var sourceType = (UserDefinedType)e.Source.Type.NormalizeExpand();
          foreach (MatchCaseExpr mc in e.Cases) {
            var wCase = MatchCasePrelude(source, sourceType, mc.Ctor, mc.Arguments, i, e.Cases.Count, w);
            EmitReturnExpr(mc.Body, mc.Body.Type, inLetExprBody, wCase, false);
            i++;
          }
        }
        // We end with applying the source expression to the delegate we just built
        wr.Write(LambdaExecute);
        TrParenExpr(e.Source, wr, inLetExprBody);

      } else if (expr is QuantifierExpr) {
        var e = (QuantifierExpr)expr;

        // Compilation does not check whether a quantifier was split.

        wr = CaptureFreeVariables(expr, true, out var su, inLetExprBody, wr);
        var logicalBody = su.Substitute(e.LogicalBody(true));

        Contract.Assert(e.Bounds != null);  // for non-ghost quantifiers, the resolver would have insisted on finding bounds
        var n = e.BoundVars.Count;
        Contract.Assert(e.Bounds.Count == n);
        var wBody = wr;
        for (int i = 0; i < n; i++) {
          var bound = e.Bounds[i];
          var bv = e.BoundVars[i];
          // emit:  Dafny.Helpers.Quantifier(rangeOfValues, isForall, bv => body)
          wBody.Write("{0}(", GetQuantifierName(TypeName(bv.Type, wBody, bv.tok)));
          CompileCollection(bound, bv, inLetExprBody, false, su, wBody, e.Bounds, e.BoundVars, i);
          wBody.Write(", {0}, ", expr is ForallExpr ? "true" : "false");
          var native = AsNativeType(e.BoundVars[i].Type);
          TargetWriter newWBody = CreateLambda(new List<Type>{ bv.Type }, e.tok, new List<string>{ IdName(bv) }, Type.Bool, wBody, untyped: true);
          newWBody = EmitReturnExpr(newWBody, false);
          wBody.Write(')');
          wBody = newWBody;
        }
        TrExpr(logicalBody, wBody, true);

      } else if (expr is SetComprehension) {
        var e = (SetComprehension)expr;
        // For "set i,j,k,l | R(i,j,k,l) :: Term(i,j,k,l)" where the term has type "G", emit something like:
        // ((System.Func<Set<G>>)(() => {
        //   var _coll = new List<G>();
        //   foreach (var tmp_l in sq.Elements) { L l = (L)tmp_l;
        //     foreach (var tmp_k in st.Elements) { K k = (K)tmp_k;
        //       for (BigInteger j = Lo; j < Hi; j++) {
        //         for (bool i in Helper.AllBooleans) {
        //           if (R(i,j,k,l)) {
        //             _coll.Add(Term(i,j,k,l));
        //           }
        //         }
        //       }
        //     }
        //   }
        //   return Dafny.Set<G>.FromCollection(_coll);
        // }))()
        wr = CaptureFreeVariables(e, true, out var su, inLetExprBody, wr);
        e = (SetComprehension)su.Substitute(e);

        Contract.Assert(e.Bounds != null);  // the resolver would have insisted on finding bounds
        var collectionName = idGenerator.FreshId("_coll");
        var bwr = CreateIIFE0(e.Type.AsSetType, e.tok, wr);
        wr = bwr;
        EmitSetBuilder_New(wr, e, collectionName);
        var n = e.BoundVars.Count;
        Contract.Assert(e.Bounds.Count == n);
        for (var i = 0; i < n; i++) {
          var bound = e.Bounds[i];
          var bv = e.BoundVars[i];
          TargetWriter collectionWriter;
          var tmpVar = idGenerator.FreshId("_compr_");
          wr = CreateForeachLoop(tmpVar, GetCollectionEnumerationType(bound, bv), IdName(bv), bv.Type, true, bv.tok, out collectionWriter, wr);
          CompileCollection(bound, bv, inLetExprBody, true, null, collectionWriter);
        }
        TargetWriter guardWriter;
        var thn = EmitIf(out guardWriter, false, wr);
        TrExpr(e.Range, guardWriter, inLetExprBody);
        EmitSetBuilder_Add(e.Type.AsSetType, collectionName, e.Term, inLetExprBody, thn);
        var s = GetCollectionBuilder_Build(e.Type.AsSetType, e.tok, collectionName, wr);
        EmitReturnExpr(s, bwr, false);

      } else if (expr is MapComprehension) {
        var e = (MapComprehension)expr;
        // For "map i | R(i) :: Term(i)" where the term has type "V" and i has type "U", emit something like:
        // ((System.Func<Map<U, V>>)(() => {
        //   var _coll = new List<Pair<U,V>>();
        //   foreach (L l in sq.Elements) {
        //     foreach (K k in st.Elements) {
        //       for (BigInteger j = Lo; j < Hi; j++) {
        //         for (bool i in Helper.AllBooleans) {
        //           if (R(i,j,k,l)) {
        //             _coll.Add(new Pair(i, Term(i));
        //           }
        //         }
        //       }
        //     }
        //   }
        //   return Dafny.Map<U, V>.FromCollection(_coll);
        // }))()
        wr = CaptureFreeVariables(e, true, out var su, inLetExprBody, wr);
        e = (MapComprehension)su.Substitute(e);

        Contract.Assert(e.Bounds != null);  // the resolver would have insisted on finding bounds
        var domtypeName = TypeName(e.Type.AsMapType.Domain, wr, e.tok);
        var rantypeName = TypeName(e.Type.AsMapType.Range, wr, e.tok);
        var collection_name = idGenerator.FreshId("_coll");
        var bwr = CreateIIFE0(e.Type.AsMapType, e.tok, wr);
        wr = bwr;
        EmitMapBuilder_New(wr, e, collection_name);
        var n = e.BoundVars.Count;
        Contract.Assert(e.Bounds.Count == n);
        for (var i = 0; i < n; i++) {
          var bound = e.Bounds[i];
          var bv = e.BoundVars[i];
          TargetWriter collectionWriter;
          var tmpVar = idGenerator.FreshId("_compr_");
          wr = CreateForeachLoop(tmpVar, GetCollectionEnumerationType(bound, bv), IdName(bv), bv.Type, true, bv.tok, out collectionWriter, wr);
          CompileCollection(bound, bv, inLetExprBody, true, null, collectionWriter);
        }
        TargetWriter guardWriter;
        var thn = EmitIf(out guardWriter, false, wr);
        TrExpr(e.Range, guardWriter, inLetExprBody);
        var termLeftWriter = EmitMapBuilder_Add(e.Type.AsMapType, e.tok, collection_name, e.Term, inLetExprBody, thn);
        if (e.TermLeft == null) {
          Contract.Assert(e.BoundVars.Count == 1);
          termLeftWriter.Write(IdName(e.BoundVars[0]));
        } else {
          TrExpr(e.TermLeft, termLeftWriter, inLetExprBody);
        }

        var s = GetCollectionBuilder_Build(e.Type.AsMapType, e.tok, collection_name, wr);
        EmitReturnExpr(s, bwr, false);

      } else if (expr is LambdaExpr) {
        var e = (LambdaExpr)expr;

        wr = CaptureFreeVariables(e, false, out var su, inLetExprBody, wr);
        wr = CreateLambda(e.BoundVars.ConvertAll(bv => bv.Type), Bpl.Token.NoToken, e.BoundVars.ConvertAll(IdName), e.Body.Type, wr);
        wr = EmitReturnExpr(wr, false);
        TrExpr(su.Substitute(e.Body), wr, inLetExprBody);

      } else if (expr is StmtExpr) {
        var e = (StmtExpr)expr;
        TrExpr(e.E, wr, inLetExprBody);

      } else if (expr is ITEExpr) {
        var e = (ITEExpr)expr;
        EmitITE(e.Test, e.Thn, e.Els, e.Type, inLetExprBody, wr);

      } else if (expr is ConcreteSyntaxExpression) {
        var e = (ConcreteSyntaxExpression)expr;
        TrExpr(e.ResolvedExpression, wr, inLetExprBody);

      } else {
        Contract.Assert(false); throw new cce.UnreachableException();  // unexpected expression
      }
    }

    protected TargetWriter CaptureFreeVariables(Expression expr, bool captureOnlyAsRequiredByTargetLanguage, out Translator.Substituter su, bool inLetExprBody, TargetWriter wr) {
      if (captureOnlyAsRequiredByTargetLanguage && TargetLambdaCanUseEnclosingLocals) {
        // nothing to do
      } else {
        CreateFreeVarSubstitution(expr, out var bvars, out var fexprs, out su);
        if (bvars.Count != 0) {
          return EmitBetaRedex(bvars.ConvertAll(IdName), fexprs, bvars.ConvertAll(bv => bv.Type), expr.Type, expr.tok, inLetExprBody, wr);
        }
      }
      su = Translator.Substituter.EMPTY;
      return wr;
    }

    void CreateFreeVarSubstitution(Expression expr, out List<BoundVar> bvars, out List<Expression> fexprs, out Translator.Substituter su) {
      Contract.Requires(expr != null);

      var fvs = Translator.ComputeFreeVariables(expr);
      var sm = new Dictionary<IVariable, Expression>();

      bvars = new List<BoundVar>();
      fexprs = new List<Expression>();
      foreach (var fv in fvs) {
        fexprs.Add(new IdentifierExpr(fv.Tok, fv.Name) {
          Var = fv, // resolved here!
          Type = fv.Type
        });
        var bv = new BoundVar(fv.Tok, fv.Name, fv.Type);
        bvars.Add(bv);
        sm[fv] = new IdentifierExpr(bv.Tok, bv.Name) {
          Var = bv, // resolved here!
          Type = bv.Type
        };
      }

      su = new Translator.Substituter(null, sm, new Dictionary<TypeParameter, Type>());
    }

    protected bool IsHandleComparison(Bpl.IToken tok, Expression e0, Expression e1, TextWriter errorWr) {
      Contract.Requires(tok != null);
      Contract.Requires(e0 != null);
      Contract.Requires(e1 != null);
      TopLevelDecl cl;
      var isHandle0 = true;
      cl = (e0.Type.NormalizeExpand() as UserDefinedType)?.ResolvedClass;
      if (cl == null || !Attributes.ContainsBool(cl.Attributes, "handle", ref isHandle0)) {
        isHandle0 = false;
      }
      var isHandle1 = true;
      cl = (e1.Type.NormalizeExpand() as UserDefinedType)?.ResolvedClass;
      if (cl == null || !Attributes.ContainsBool(cl.Attributes, "handle", ref isHandle1)) {
        isHandle1 = false;
      }
      if (isHandle0 && isHandle1) {
        return true;
      } else if (isHandle0 || isHandle1) {
        Error(tok, "Comparison of a handle can only be with another handle", errorWr);
      }
      return false;
    }

    protected void TrStringLiteral(StringLiteralExpr str, TextWriter wr) {
      Contract.Requires(str != null);
      Contract.Requires(wr != null);
      EmitStringLiteral((string)str.Value, str.IsVerbatim, wr);
    }

    /// <summary>
    /// Try to evaluate "expr" into one BigInteger.  On success, return it; otherwise, return "null".
    /// </summary>
    /// <param name="expr"></param>
    /// <returns></returns>
    public static Nullable<BigInteger> PartiallyEvaluate(Expression expr) {
      Contract.Requires(expr != null);
      expr = expr.Resolved;
      if (expr is LiteralExpr) {
        var e = (LiteralExpr)expr;
        if (e.Value is BigInteger) {
          return (BigInteger)e.Value;
        }
      } else if (expr is BinaryExpr) {
        var e = (BinaryExpr)expr;
        switch (e.ResolvedOp) {
          case BinaryExpr.ResolvedOpcode.Add:
          case BinaryExpr.ResolvedOpcode.Sub:
          case BinaryExpr.ResolvedOpcode.Mul:
            // possibly the most important case is Sub, since that's how NegationExpression's end up
            var arg0 = PartiallyEvaluate(e.E0);
            var arg1 = arg0 == null ? null : PartiallyEvaluate(e.E1);
            if (arg1 != null) {
              switch (e.ResolvedOp) {
                case BinaryExpr.ResolvedOpcode.Add:
                  return arg0 + arg1;
                case BinaryExpr.ResolvedOpcode.Sub:
                  return arg0 - arg1;
                case BinaryExpr.ResolvedOpcode.Mul:
                  return arg0 * arg1;
                default:
                  Contract.Assert(false);
                  break;  // please compiler
              }
            }
            break;
          default:
            break;
        }
      }
      return null;
    }

    TargetWriter TrCasePattern(CasePattern<BoundVar> pat, string rhsString, Type rhsType, Type bodyType, TargetWriter wr) {
      Contract.Requires(pat != null);
      Contract.Requires(rhsString != null);
      Contract.Requires(rhsType != null);
      Contract.Requires(bodyType != null);
      Contract.Requires(wr != null);

      if (pat.Var != null) {
        var bv = pat.Var;
        if (!bv.IsReallyGhost) {
          CreateIIFE(IdProtect(bv.CompileName), bv.Type, bv.Tok, bodyType, pat.tok, wr, out var wrRhs, out var wrBody);
          wrRhs = EmitDowncastIfNecessary(rhsType, bv.Type, bv.tok, wrRhs);
          wrRhs.Write(rhsString);
          return wrBody;
        }
      } else if (pat.Arguments != null) {
        var ctor = pat.Ctor;
        Contract.Assert(ctor != null);  // follows from successful resolution
        Contract.Assert(pat.Arguments.Count == ctor.Formals.Count);  // follows from successful resolution
        Contract.Assert(ctor.EnclosingDatatype.TypeArgs.Count == rhsType.NormalizeExpand().TypeArgs.Count);
        var typeSubst = Resolver.TypeSubstitutionMap(ctor.EnclosingDatatype.TypeArgs, rhsType.NormalizeExpand().TypeArgs);
        var k = 0;  // number of non-ghost formals processed
        for (int i = 0; i < pat.Arguments.Count; i++) {
          var arg = pat.Arguments[i];
          var formal = ctor.Formals[i];
          if (formal.IsReallyGhost) {
            // nothing to compile, but do a sanity check
            Contract.Assert(!Contract.Exists(arg.Vars, bv => !bv.IsReallyGhost));
          } else {
            var sw = new TargetWriter(wr.IndentLevel, true);
            EmitDestructor(rhsString, formal, k, ctor, ((DatatypeValue)pat.Expr).InferredTypeArgs, arg.Expr.Type, sw);
            wr = TrCasePattern(arg, sw.ToString(), Resolver.SubstType(formal.Type, typeSubst), bodyType, wr);
            k++;
          }
        }
      }
      return wr;
    }

    void CompileSpecialFunctionCallExpr(FunctionCallExpr e, TargetWriter wr, bool inLetExprBody, FCE_Arg_Translator tr) {
      string name = e.Function.Name;

      if (name == "RotateLeft") {
        EmitRotate(e.Receiver, e.Args[0], true, wr, inLetExprBody, tr);
      } else if (name == "RotateRight") {
        EmitRotate(e.Receiver, e.Args[0], false, wr, inLetExprBody, tr);
      } else {
        CompileFunctionCallExpr(e, wr, inLetExprBody, tr);
      }
    }

    void CompileFunctionCallExpr(FunctionCallExpr e, TargetWriter wr, bool inLetExprBody, FCE_Arg_Translator tr) {
      Contract.Requires(e != null && e.Function != null);
      Contract.Requires(wr != null);
      Contract.Requires(tr != null);
      Function f = e.Function;

      bool is_shared = f.ResultUsage.IsSharedKind;

      var toType = thisContext == null ? e.Type : Resolver.SubstType(e.Type, thisContext.ParentFormalTypeParametersToActuals);
      wr = EmitCoercionIfNecessary(f.Original.ResultType, toType, e.tok, wr);

      if (is_shared) { wr.Write("*("); }
      
      var customReceiver = !(f.EnclosingClass is TraitDecl) && NeedsCustomReceiver(f);
      string qual = "";
      string compileName = "";
      if (f.IsExtern(out qual, out compileName) && qual != null) {
        wr.Write("{0}{1}", qual, ModuleSeparator);
      } else if (f.IsStatic || customReceiver) {
        wr.Write("{0}{1}", TypeName_Companion(e.Receiver.Type, wr, e.tok, f), ModuleSeparator);
        compileName = IdName(f);
      } else {
        wr.Write("(");
        tr(e.Receiver, wr, inLetExprBody);
        wr.Write("){0}", ClassAccessor);
        compileName = IdName(f);
      }
      var typeArgs = CombineAllTypeArguments(f, e.TypeApplication_AtEnclosingClass, e.TypeApplication_JustFunction);
      EmitNameAndActualTypeArgs(compileName, TypeArgumentInstantiation.ToActuals(ForTypeParameters(typeArgs, f, false)), f.tok, wr);
      wr.Write("(");
      var sep = "";
      EmitTypeDescriptorsActuals(ForTypeDescriptors(typeArgs, f, false), e.tok, wr, ref sep);
      if (customReceiver) {
        wr.Write(sep);
        var w = EmitCoercionIfNecessary(e.Receiver.Type, UserDefinedType.UpcastToMemberEnclosingType(e.Receiver.Type, e.Function), e.tok, wr);
        TrExpr(e.Receiver, w, inLetExprBody);
        sep = ", ";
      }
      for (int i = 0; i < e.Args.Count; i++) {
        if (!e.Function.Formals[i].IsReallyGhost) {
          wr.Write(sep);
          var fromType = e.Args[i].Type;
          var w = EmitCoercionIfNecessary(fromType, e.Function.Formals[i].Type, tok: e.tok, wr: wr);
          var instantiatedToType = Resolver.SubstType(e.Function.Formals[i].Type, e.TypeArgumentSubstitutionsWithParents());
          w = EmitDowncastIfNecessary(fromType, instantiatedToType, e.tok, w);
          tr(e.Args[i], w, inLetExprBody);
          sep = ", ";
        }
      }
      wr.Write(")");
      if (is_shared) { wr.Write(")"); }
    }

    private bool IsComparisonToZero(BinaryExpr expr, out Expression/*?*/ arg, out int sign, out bool negated) {
      int s;
      if (IsComparisonWithZeroOnRight(expr.Op, expr.E1, out s, out negated)) {
        // e.g. x < 0
        arg = expr.E0;
        sign = s;
        return true;
      } else if (IsComparisonWithZeroOnRight(expr.Op, expr.E0, out s, out negated)) {
        // e.g. 0 < x, equivalent to x < 0
        arg = expr.E1;
        sign = -s;
        return true;
      } else {
        arg = null;
        sign = 0;
        return false;
      }
    }

    private bool IsComparisonWithZeroOnRight(
      BinaryExpr.Opcode op, Expression right,
      out int sign, out bool negated) {

      var rightVal = PartiallyEvaluate(right);
      if (rightVal == null || rightVal != BigInteger.Zero) {
        sign = 0; // need to assign something
        negated = true; // need to assign something
        return false;
      } else {
        switch (op) {
          case BinaryExpr.Opcode.Lt:
            // x < 0 <==> sign(x) == -1
            sign = -1;
            negated = false;
            return true;
          case BinaryExpr.Opcode.Le:
            // x <= 0 <==> sign(x) != 1
            sign = 1;
            negated = true;
            return true;
          case BinaryExpr.Opcode.Eq:
            // x == 0 <==> sign(x) == 0
            sign = 0;
            negated = false;
            return true;
          case BinaryExpr.Opcode.Neq:
            // x != 0 <==> sign(x) != 0
            sign = 0;
            negated = true;
            return true;
          case BinaryExpr.Opcode.Gt:
            // x > 0 <==> sign(x) == 1
            sign = 1;
            negated = false;
            return true;
          case BinaryExpr.Opcode.Ge:
            // x >= 0 <==> sign(x) != -1
            sign = -1;
            negated = true;
            return true;
          default:
            sign = 0; // need to assign something
            negated = false; // ditto
            return false;
        }
      }
    }

    public virtual bool SupportsInMemoryCompilation => true;
    public virtual bool TextualTargetIsExecutable => false;

    /// <summary>
    /// Compile the target program known as "dafnyProgramName".
    /// "targetProgramText" contains the program text.
    /// If "targetFilename" is non-null, it is the name of the target program text stored as a
    /// file. "targetFileName" must be non-null if "otherFileNames" is nonempty.
    /// "otherFileNames" is a list of other files to include in the compilation.
    ///
    /// When "callToMain" is non-null, the program contains a "Main()" program.
    ///
    /// Upon successful compilation, "runAfterCompile" says whether or not to execute the program.
    ///
    /// Output any errors to "outputWriter".
    /// Returns "false" if there were errors. Then, "compilationResult" should not be used.
    /// Returns "true" on success. Then, "compilationResult" is a value that can be passed in to
    /// the instance's "RunTargetProgram" method.
    /// </summary>
    public virtual bool CompileTargetProgram(string dafnyProgramName, string targetProgramText, string/*?*/ callToMain, string/*?*/ targetFilename, ReadOnlyCollection<string> otherFileNames,
      bool runAfterCompile, TextWriter outputWriter, out object compilationResult) {
      Contract.Requires(dafnyProgramName != null);
      Contract.Requires(targetProgramText != null);
      Contract.Requires(otherFileNames != null);
      Contract.Requires(otherFileNames.Count == 0 || targetFilename != null);
      Contract.Requires(this.SupportsInMemoryCompilation || targetFilename != null);
      Contract.Requires(!runAfterCompile || callToMain != null);
      Contract.Requires(outputWriter != null);

      compilationResult = null;
      return true;
    }

    /// <summary>
    /// Runs a target program after it has been successfully compiled.
    /// dafnyProgram, targetProgramText, targetFilename, and otherFileNames are the same as the corresponding parameters to "CompileTargetProgram".
    /// "callToMain" is an explicit call to Main, as required by the target compilation language.
    /// "compilationResult" is a value returned by "CompileTargetProgram" for these parameters.
    ///
    /// Returns "true" on success, "false" on error. Any errors are output to "outputWriter".
    /// </summary>
    public virtual bool RunTargetProgram(string dafnyProgramName, string targetProgramText, string/*?*/ callToMain, string/*?*/ targetFilename, ReadOnlyCollection<string> otherFileNames,
      object compilationResult, TextWriter outputWriter) {
      Contract.Requires(dafnyProgramName != null);
      Contract.Requires(targetProgramText != null);
      Contract.Requires(otherFileNames != null);
      Contract.Requires(otherFileNames.Count == 0 || targetFilename != null);
      Contract.Requires(outputWriter != null);
      return true;
    }
  }

  public class CoverageInstrumenter
  {
    private readonly Compiler compiler;
    private List<(Bpl.IToken, string)>/*?*/ legend;  // non-null implies DafnyOptions.O.CoverageLegendFile is non-null

    public CoverageInstrumenter(Compiler compiler) {
      this.compiler = compiler;
      if (DafnyOptions.O.CoverageLegendFile != null) {
        legend = new List<(Bpl.IToken, string)>();
      }
    }

    public bool IsRecording {
      get => legend != null;
    }

    public void Instrument(Bpl.IToken tok, string description, TargetWriter wr) {
      Contract.Requires(tok != null);
      Contract.Requires(description != null);
      Contract.Requires(wr != null || !IsRecording);
      if (legend != null) {
        wr.Write("DafnyProfiling.CodeCoverage.Record({0})", legend.Count);
        compiler.EndStmt(wr);
        legend.Add((tok, description));
      }
    }

    public void UnusedInstrumentationPoint(Bpl.IToken tok, string description) {
      Contract.Requires(tok != null);
      Contract.Requires(description != null);
      if (legend != null) {
        legend.Add((tok, description));
      }
    }

    public void InstrumentExpr(Bpl.IToken tok, string description, bool resultValue, TargetWriter wr) {
      Contract.Requires(tok != null);
      Contract.Requires(description != null);
      Contract.Requires(wr != null || !IsRecording);
      if (legend != null) {
        // The "Record" call always returns "true", so we negate it to get the value "false"
        wr.Write("{1}DafnyProfiling.CodeCoverage.Record({0})", legend.Count, resultValue ? "" : "!");
        legend.Add((tok, description));
      }
    }

    /// <summary>
    /// Should be called once "n" has reached its final value
    /// </summary>
    public void EmitSetup(TargetWriter wr) {
      Contract.Requires(wr != null);
      if (legend != null) {
        wr.Write("DafnyProfiling.CodeCoverage.Setup({0})", legend.Count);
        compiler.EndStmt(wr);
      }
    }

    public void EmitTearDown(TargetWriter wr) {
      Contract.Requires(wr != null);
      if (legend != null) {
        wr.Write("DafnyProfiling.CodeCoverage.TearDown()");
        compiler.EndStmt(wr);
      }
    }

    public void WriteLegendFile() {
      if (legend != null) {
        var filename = DafnyOptions.O.CoverageLegendFile;
        Contract.Assert(filename != null);
        using (TextWriter wr = filename == "-" ? System.Console.Out : new StreamWriter(new FileStream(Path.GetFullPath(filename), System.IO.FileMode.Create))) {
          for (var i = 0; i < legend.Count; i++) {
            var e = legend[i];
            wr.WriteLine("{0}: {1}({2},{3}): {4}", i, e.Item1.filename, e.Item1.line, e.Item1.col, e.Item2);
          }
        }
        legend = null;
      }
    }
  }

  public class TargetWriter : TextWriter {
    public TargetWriter(int indent = 0, bool suppressInitialIndent = false) {
      Contract.Requires(0 <= indent);
      IndentLevel = indent;
      IndentString = new string(' ', indent);
      indentPending = !suppressInitialIndent;
    }
    public override Encoding Encoding {
      get { return Encoding.Default; }
    }

    // ----- Indention ------------------------------

    public readonly int IndentLevel;
    public const int IndentAmount = 2;
    const string IndentAmountString = "  ";  // this should have the length IndentAmount
    public readonly string IndentString;
    public string UnIndentString => new string(' ', Math.Max(IndentLevel - IndentAmount, 0));
    public void IndentLess() {
      indentPending = false;
      Write(UnIndentString);
    }

    // ----- Things ------------------------------

    private readonly List<object> things = new List<object>();

    private void AddThing(object thing) {
      if (indentPending) {
        indentPending = false;
        things.Add(IndentString);
      }
      things.Add(thing);
      if (thing is BlockTargetWriter btw && btw.EndsWithNewLine) {
        indentPending = true;
      } else {
        indentPending = false;
      }
    }

    public void Append(TargetWriter wr) {
      Contract.Requires(wr != null);
      AddThing(wr);
    }

    // ----- Writing ------------------------------

    bool indentPending; // generally, true iff the last char written was '\n'

    public override void Write(char[] buffer, int index, int count) {
      if (indentPending && count == 1 && buffer[index] == '\n') {
        // avoid writing whitespace-only line
        indentPending = false;
      }
      AddThing(new string(buffer, index, count));
      indentPending = count > 0 && buffer[index + count - 1] == '\n';
    }
    public override void Write(string value) {
      if (indentPending && value == "\n") {
        indentPending = false;
      }
      AddThing(value);
      indentPending = value.EndsWith("\n");
    }
    public override void Write(char value) {
      if (indentPending && value == '\n') {
        indentPending = false;
      }
      AddThing(new string(value, 1));
      indentPending = value == '\n';
    }

    public void RepeatWrite(int times, string template, string separator) {
      Contract.Requires(1 <= times);
      Contract.Requires(template != null);
      Contract.Requires(separator != null);
      string sep = "";
      for (int i = 0; i < times; i++) {
        Write(sep);
        Write(template, i);
        sep = separator;
      }
    }

    public void WriteError(string format, params string[] args) {
      var oldIndentPending = indentPending;
      WriteLine(format, args);
      indentPending = oldIndentPending;
    }

    /// <summary>
    /// Fork() is to be used when the new TargetWriter will not start with an indent
    /// and will not end with a newline. (However, contrary to what the name of this parameter may
    /// suggest, the new TargetWriter may choose to add its own newlines and indents in the middele.)
    /// See also ForkSection().
    /// </summary>
    public TargetWriter Fork() {
      var ans = new TargetWriter(IndentLevel, true);
      AddThing(ans);
      return ans;
    }

    /// <summary>
    /// ForkSection() says that the new TargetWriter will form a block of complete lines,
    /// each beginning with an indent and ending with a newline.
    /// </summary>
    public TargetWriter ForkSection(bool indentMore = false) {
      indentPending = false;
      var ans = new TargetWriter(IndentLevel + (indentMore ? IndentAmount : 0));
      AddThing(ans);
      indentPending = true;
      return ans;
    }

    // ----- Nested blocks ------------------------------

    public BlockTargetWriter NewBlock(string header, string/*?*/ footer = null,
      BlockTargetWriter.BraceStyle open = BlockTargetWriter.BraceStyle.Space,
      BlockTargetWriter.BraceStyle close = BlockTargetWriter.BraceStyle.Newline) {
      Contract.Requires(header != null);
      var btw = new BlockTargetWriter(IndentLevel + IndentAmount, header, footer);
      btw.SetBraceStyle(open, close);
      AddThing(btw);
      return btw;
    }
    public BlockTargetWriter NewNamedBlock(string headerFormat, params object[] headerArgs) {
      Contract.Requires(headerFormat != null);
      return NewBigBlock(string.Format(headerFormat, headerArgs), null);
    }
    public BlockTargetWriter NewBigBlock(string header, string/*?*/ footer) {
      Contract.Requires(header != null);
      var btw = new BlockTargetWriter(IndentLevel + IndentAmount, header, footer);
      btw.SetBraceStyle(BlockTargetWriter.BraceStyle.Space, BlockTargetWriter.BraceStyle.Newline);
      AddThing(btw);
      return btw;
    }
    public BlockTargetWriter NewExprBlock(string headerFormat, params object[] headerArgs) {
      Contract.Requires(headerFormat != null);
      return NewBigExprBlock(string.Format(headerFormat, headerArgs), null);
    }
    public BlockTargetWriter NewBigExprBlock(string header, string/*?*/ footer) {
      Contract.Requires(header != null);
      var btw = new BlockTargetWriter(IndentLevel + IndentAmount, header, footer);
      btw.SetBraceStyle(BlockTargetWriter.BraceStyle.Space, BlockTargetWriter.BraceStyle.Nothing);
      AddThing(btw);
      return btw;
    }
    public BlockTargetWriter NewBlockWithPrefix(string headerFormat, string prefixFormat, params object[] headerArgs) {
      Contract.Requires(headerFormat != null);
      Contract.Requires(prefixFormat != null);
      var btw = new BlockTargetWriter(IndentLevel + IndentAmount, string.Format(headerFormat, headerArgs), null);
      btw.SetBraceStyle(BlockTargetWriter.BraceStyle.Space, BlockTargetWriter.BraceStyle.Newline);
      btw.BodyPrefix = string.Format(prefixFormat, headerArgs);
      AddThing(btw);
      return btw;
    }

    public TargetWriter NewSection() {
      var w = new TargetWriter(IndentLevel);
      AddThing(w);
      return w;
    }

    public FileTargetWriter NewFile(string filename) {
      var w = new FileTargetWriter(filename);
      AddThing(w);
      return w;
    }

    // ----- Collection ------------------------------

    public override string ToString() {
      var sw = new StringWriter();
      var q = new Queue<FileTargetWriter>();
      Collect(sw, q);
      while (q.Count != 0) {
        var ftw = q.Dequeue();
        sw.WriteLine("#file {0}", ftw.Filename);
        ftw.Collect(sw, q);
      }
      return sw.ToString();
    }
    public virtual void Collect(TextWriter wr, Queue<FileTargetWriter> files) {
      Contract.Requires(wr != null);
      Contract.Requires(files != null);

      Contract.Assert(things != null);
      CollectThings(wr, files);
    }
    protected void CollectThings(TextWriter wr, Queue<FileTargetWriter> files) {
      Contract.Requires(wr != null);
      Contract.Requires(files != null);

      foreach (var o in things) {
        if (o is string s) {
          wr.Write(s);
        } else if (o is FileTargetWriter ftw) {
          files.Enqueue(ftw);
        } else if (o is TargetWriter tw) {
          tw.Collect(wr, files);
        } else {
          wr.Write(o.ToString());
        }
      }
    }
  }
  public class BlockTargetWriter : TargetWriter {
    string header;
    public enum BraceStyle { Nothing, Space, Newline }
    BraceStyle openBraceStyle = BraceStyle.Space;
    BraceStyle closeBraceStyle = BraceStyle.Newline;  // must be set to its final value before the BlockTargetWriter is .Add'ed to an enclosing TargetWriter
    public string BodyPrefix;  // just inside the open curly (before the newline)
    public string BodySuffix;  // just before the close curly
    public string Footer;  // just after the close curly
    public BlockTargetWriter(int indentInsideBraces, string header, string/*?*/ footer)
    : base(indentInsideBraces) {
      Contract.Requires(IndentAmount <= indentInsideBraces);
      Contract.Requires(header != null);
      this.header = header;
      this.Footer = footer;
    }
    public void SetBraceStyle(BraceStyle open, BraceStyle close) {
      this.openBraceStyle = open;
      this.closeBraceStyle = close;
    }
    public bool EndsWithNewLine {
      get => closeBraceStyle == BraceStyle.Newline;
    }
    public void AppendHeader(string format, params object[] args) {
      Contract.Requires(format != null);
      header += args.Length == 0 ? format : string.Format(format, args);
    }

    public override void Collect(TextWriter wr, Queue<FileTargetWriter> files) {
      wr.Write(header);
      switch (openBraceStyle) {
        case BraceStyle.Nothing:
        default:
          break;
        case BraceStyle.Space:
          wr.Write(" ");
          break;
        case BraceStyle.Newline:
          wr.WriteLine();
          wr.Write(UnIndentString);
          break;
      }
      wr.WriteLine("{{{0}", BodyPrefix != null ? " " + BodyPrefix : "");
      CollectThings(wr, files);
      if (BodySuffix != null) {
        wr.Write(BodySuffix);
      }
      wr.Write(UnIndentString);
      wr.Write("}");
      if (Footer != null) {
        wr.Write(Footer);
      }
      switch (closeBraceStyle) {
        case BraceStyle.Nothing:
        default:
          break;
        case BraceStyle.Space:
          wr.Write(" ");
          break;
        case BraceStyle.Newline:
          wr.WriteLine();
          break;
      }
    }
  }

  public class FileTargetWriter : TargetWriter {
    public readonly string Filename;

    public FileTargetWriter(string filename) {
      Contract.Requires(filename != null);
      Filename = filename;
    }
  }
}
